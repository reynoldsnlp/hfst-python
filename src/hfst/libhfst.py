# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _libhfst
else:
    import _libhfst

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst.delete_SwigPyIterator

    def value(self):
        return _libhfst.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _libhfst.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _libhfst.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _libhfst.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _libhfst.SwigPyIterator_equal(self, x)

    def copy(self):
        return _libhfst.SwigPyIterator_copy(self)

    def next(self):
        return _libhfst.SwigPyIterator_next(self)

    def __next__(self):
        return _libhfst.SwigPyIterator___next__(self)

    def previous(self):
        return _libhfst.SwigPyIterator_previous(self)

    def advance(self, n):
        return _libhfst.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _libhfst.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _libhfst.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _libhfst.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _libhfst.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _libhfst.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _libhfst.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _libhfst:
_libhfst.SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.StringVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.StringVector___bool__(self)

    def __len__(self):
        return _libhfst.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.StringVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.StringVector_pop(self)

    def append(self, x):
        return _libhfst.StringVector_append(self, x)

    def empty(self):
        return _libhfst.StringVector_empty(self)

    def size(self):
        return _libhfst.StringVector_size(self)

    def swap(self, v):
        return _libhfst.StringVector_swap(self, v)

    def begin(self):
        return _libhfst.StringVector_begin(self)

    def end(self):
        return _libhfst.StringVector_end(self)

    def rbegin(self):
        return _libhfst.StringVector_rbegin(self)

    def rend(self):
        return _libhfst.StringVector_rend(self)

    def clear(self):
        return _libhfst.StringVector_clear(self)

    def get_allocator(self):
        return _libhfst.StringVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.StringVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.StringVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.StringVector_swiginit(self, _libhfst.new_StringVector(*args))

    def push_back(self, x):
        return _libhfst.StringVector_push_back(self, x)

    def front(self):
        return _libhfst.StringVector_front(self)

    def back(self):
        return _libhfst.StringVector_back(self)

    def assign(self, n, x):
        return _libhfst.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.StringVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.StringVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.StringVector_reserve(self, n)

    def capacity(self):
        return _libhfst.StringVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_StringVector

# Register StringVector in _libhfst:
_libhfst.StringVector_swigregister(StringVector)

class StringPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.StringPair_swiginit(self, _libhfst.new_StringPair(*args))
    first = property(_libhfst.StringPair_first_get, _libhfst.StringPair_first_set)
    second = property(_libhfst.StringPair_second_get, _libhfst.StringPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst.delete_StringPair

# Register StringPair in _libhfst:
_libhfst.StringPair_swigregister(StringPair)

class StringPairVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.StringPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.StringPairVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.StringPairVector___bool__(self)

    def __len__(self):
        return _libhfst.StringPairVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.StringPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.StringPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.StringPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.StringPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.StringPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.StringPairVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.StringPairVector_pop(self)

    def append(self, x):
        return _libhfst.StringPairVector_append(self, x)

    def empty(self):
        return _libhfst.StringPairVector_empty(self)

    def size(self):
        return _libhfst.StringPairVector_size(self)

    def swap(self, v):
        return _libhfst.StringPairVector_swap(self, v)

    def begin(self):
        return _libhfst.StringPairVector_begin(self)

    def end(self):
        return _libhfst.StringPairVector_end(self)

    def rbegin(self):
        return _libhfst.StringPairVector_rbegin(self)

    def rend(self):
        return _libhfst.StringPairVector_rend(self)

    def clear(self):
        return _libhfst.StringPairVector_clear(self)

    def get_allocator(self):
        return _libhfst.StringPairVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.StringPairVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.StringPairVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.StringPairVector_swiginit(self, _libhfst.new_StringPairVector(*args))

    def push_back(self, x):
        return _libhfst.StringPairVector_push_back(self, x)

    def front(self):
        return _libhfst.StringPairVector_front(self)

    def back(self):
        return _libhfst.StringPairVector_back(self)

    def assign(self, n, x):
        return _libhfst.StringPairVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.StringPairVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.StringPairVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.StringPairVector_reserve(self, n)

    def capacity(self):
        return _libhfst.StringPairVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_StringPairVector

# Register StringPairVector in _libhfst:
_libhfst.StringPairVector_swigregister(StringPairVector)

class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.FloatVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.FloatVector___bool__(self)

    def __len__(self):
        return _libhfst.FloatVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.FloatVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.FloatVector_pop(self)

    def append(self, x):
        return _libhfst.FloatVector_append(self, x)

    def empty(self):
        return _libhfst.FloatVector_empty(self)

    def size(self):
        return _libhfst.FloatVector_size(self)

    def swap(self, v):
        return _libhfst.FloatVector_swap(self, v)

    def begin(self):
        return _libhfst.FloatVector_begin(self)

    def end(self):
        return _libhfst.FloatVector_end(self)

    def rbegin(self):
        return _libhfst.FloatVector_rbegin(self)

    def rend(self):
        return _libhfst.FloatVector_rend(self)

    def clear(self):
        return _libhfst.FloatVector_clear(self)

    def get_allocator(self):
        return _libhfst.FloatVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.FloatVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.FloatVector_swiginit(self, _libhfst.new_FloatVector(*args))

    def push_back(self, x):
        return _libhfst.FloatVector_push_back(self, x)

    def front(self):
        return _libhfst.FloatVector_front(self)

    def back(self):
        return _libhfst.FloatVector_back(self)

    def assign(self, n, x):
        return _libhfst.FloatVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.FloatVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.FloatVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.FloatVector_reserve(self, n)

    def capacity(self):
        return _libhfst.FloatVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_FloatVector

# Register FloatVector in _libhfst:
_libhfst.FloatVector_swigregister(FloatVector)

class StringSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.StringSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.StringSet___nonzero__(self)

    def __bool__(self):
        return _libhfst.StringSet___bool__(self)

    def __len__(self):
        return _libhfst.StringSet___len__(self)

    def append(self, x):
        return _libhfst.StringSet_append(self, x)

    def __contains__(self, x):
        return _libhfst.StringSet___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst.StringSet___getitem__(self, i)

    def add(self, x):
        return _libhfst.StringSet_add(self, x)

    def discard(self, x):
        return _libhfst.StringSet_discard(self, x)

    def __init__(self, *args):
        _libhfst.StringSet_swiginit(self, _libhfst.new_StringSet(*args))

    def empty(self):
        return _libhfst.StringSet_empty(self)

    def size(self):
        return _libhfst.StringSet_size(self)

    def clear(self):
        return _libhfst.StringSet_clear(self)

    def swap(self, v):
        return _libhfst.StringSet_swap(self, v)

    def count(self, x):
        return _libhfst.StringSet_count(self, x)

    def begin(self):
        return _libhfst.StringSet_begin(self)

    def end(self):
        return _libhfst.StringSet_end(self)

    def rbegin(self):
        return _libhfst.StringSet_rbegin(self)

    def rend(self):
        return _libhfst.StringSet_rend(self)

    def erase(self, *args):
        return _libhfst.StringSet_erase(self, *args)

    def find(self, x):
        return _libhfst.StringSet_find(self, x)

    def lower_bound(self, x):
        return _libhfst.StringSet_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst.StringSet_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst.StringSet_equal_range(self, x)

    def insert(self, __x):
        return _libhfst.StringSet_insert(self, __x)
    __swig_destroy__ = _libhfst.delete_StringSet

# Register StringSet in _libhfst:
_libhfst.StringSet_swigregister(StringSet)

class StringPairSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.StringPairSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.StringPairSet___nonzero__(self)

    def __bool__(self):
        return _libhfst.StringPairSet___bool__(self)

    def __len__(self):
        return _libhfst.StringPairSet___len__(self)

    def append(self, x):
        return _libhfst.StringPairSet_append(self, x)

    def __contains__(self, x):
        return _libhfst.StringPairSet___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst.StringPairSet___getitem__(self, i)

    def add(self, x):
        return _libhfst.StringPairSet_add(self, x)

    def discard(self, x):
        return _libhfst.StringPairSet_discard(self, x)

    def __init__(self, *args):
        _libhfst.StringPairSet_swiginit(self, _libhfst.new_StringPairSet(*args))

    def empty(self):
        return _libhfst.StringPairSet_empty(self)

    def size(self):
        return _libhfst.StringPairSet_size(self)

    def clear(self):
        return _libhfst.StringPairSet_clear(self)

    def swap(self, v):
        return _libhfst.StringPairSet_swap(self, v)

    def count(self, x):
        return _libhfst.StringPairSet_count(self, x)

    def begin(self):
        return _libhfst.StringPairSet_begin(self)

    def end(self):
        return _libhfst.StringPairSet_end(self)

    def rbegin(self):
        return _libhfst.StringPairSet_rbegin(self)

    def rend(self):
        return _libhfst.StringPairSet_rend(self)

    def erase(self, *args):
        return _libhfst.StringPairSet_erase(self, *args)

    def find(self, x):
        return _libhfst.StringPairSet_find(self, x)

    def lower_bound(self, x):
        return _libhfst.StringPairSet_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst.StringPairSet_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst.StringPairSet_equal_range(self, x)

    def insert(self, __x):
        return _libhfst.StringPairSet_insert(self, __x)
    __swig_destroy__ = _libhfst.delete_StringPairSet

# Register StringPairSet in _libhfst:
_libhfst.StringPairSet_swigregister(StringPairSet)

class HfstTransducerVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstTransducerVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstTransducerVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstTransducerVector___bool__(self)

    def __len__(self):
        return _libhfst.HfstTransducerVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.HfstTransducerVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.HfstTransducerVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.HfstTransducerVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.HfstTransducerVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.HfstTransducerVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.HfstTransducerVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.HfstTransducerVector_pop(self)

    def append(self, x):
        return _libhfst.HfstTransducerVector_append(self, x)

    def empty(self):
        return _libhfst.HfstTransducerVector_empty(self)

    def size(self):
        return _libhfst.HfstTransducerVector_size(self)

    def swap(self, v):
        return _libhfst.HfstTransducerVector_swap(self, v)

    def begin(self):
        return _libhfst.HfstTransducerVector_begin(self)

    def end(self):
        return _libhfst.HfstTransducerVector_end(self)

    def rbegin(self):
        return _libhfst.HfstTransducerVector_rbegin(self)

    def rend(self):
        return _libhfst.HfstTransducerVector_rend(self)

    def clear(self):
        return _libhfst.HfstTransducerVector_clear(self)

    def get_allocator(self):
        return _libhfst.HfstTransducerVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.HfstTransducerVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.HfstTransducerVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.HfstTransducerVector_swiginit(self, _libhfst.new_HfstTransducerVector(*args))

    def push_back(self, x):
        return _libhfst.HfstTransducerVector_push_back(self, x)

    def front(self):
        return _libhfst.HfstTransducerVector_front(self)

    def back(self):
        return _libhfst.HfstTransducerVector_back(self)

    def assign(self, n, x):
        return _libhfst.HfstTransducerVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.HfstTransducerVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.HfstTransducerVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.HfstTransducerVector_reserve(self, n)

    def capacity(self):
        return _libhfst.HfstTransducerVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_HfstTransducerVector

# Register HfstTransducerVector in _libhfst:
_libhfst.HfstTransducerVector_swigregister(HfstTransducerVector)

class HfstSymbolSubstitutions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstSymbolSubstitutions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstSymbolSubstitutions___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstSymbolSubstitutions___bool__(self)

    def __len__(self):
        return _libhfst.HfstSymbolSubstitutions___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _libhfst.HfstSymbolSubstitutions___getitem__(self, key)

    def __delitem__(self, key):
        return _libhfst.HfstSymbolSubstitutions___delitem__(self, key)

    def has_key(self, key):
        return _libhfst.HfstSymbolSubstitutions_has_key(self, key)

    def keys(self):
        return _libhfst.HfstSymbolSubstitutions_keys(self)

    def values(self):
        return _libhfst.HfstSymbolSubstitutions_values(self)

    def items(self):
        return _libhfst.HfstSymbolSubstitutions_items(self)

    def __contains__(self, key):
        return _libhfst.HfstSymbolSubstitutions___contains__(self, key)

    def key_iterator(self):
        return _libhfst.HfstSymbolSubstitutions_key_iterator(self)

    def value_iterator(self):
        return _libhfst.HfstSymbolSubstitutions_value_iterator(self)

    def __setitem__(self, *args):
        return _libhfst.HfstSymbolSubstitutions___setitem__(self, *args)

    def asdict(self):
        return _libhfst.HfstSymbolSubstitutions_asdict(self)

    def __init__(self, *args):
        _libhfst.HfstSymbolSubstitutions_swiginit(self, _libhfst.new_HfstSymbolSubstitutions(*args))

    def empty(self):
        return _libhfst.HfstSymbolSubstitutions_empty(self)

    def size(self):
        return _libhfst.HfstSymbolSubstitutions_size(self)

    def swap(self, v):
        return _libhfst.HfstSymbolSubstitutions_swap(self, v)

    def begin(self):
        return _libhfst.HfstSymbolSubstitutions_begin(self)

    def end(self):
        return _libhfst.HfstSymbolSubstitutions_end(self)

    def rbegin(self):
        return _libhfst.HfstSymbolSubstitutions_rbegin(self)

    def rend(self):
        return _libhfst.HfstSymbolSubstitutions_rend(self)

    def clear(self):
        return _libhfst.HfstSymbolSubstitutions_clear(self)

    def get_allocator(self):
        return _libhfst.HfstSymbolSubstitutions_get_allocator(self)

    def count(self, x):
        return _libhfst.HfstSymbolSubstitutions_count(self, x)

    def erase(self, *args):
        return _libhfst.HfstSymbolSubstitutions_erase(self, *args)

    def find(self, x):
        return _libhfst.HfstSymbolSubstitutions_find(self, x)

    def lower_bound(self, x):
        return _libhfst.HfstSymbolSubstitutions_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst.HfstSymbolSubstitutions_upper_bound(self, x)
    __swig_destroy__ = _libhfst.delete_HfstSymbolSubstitutions

# Register HfstSymbolSubstitutions in _libhfst:
_libhfst.HfstSymbolSubstitutions_swigregister(HfstSymbolSubstitutions)

class HfstSymbolPairSubstitutions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstSymbolPairSubstitutions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstSymbolPairSubstitutions___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstSymbolPairSubstitutions___bool__(self)

    def __len__(self):
        return _libhfst.HfstSymbolPairSubstitutions___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _libhfst.HfstSymbolPairSubstitutions___getitem__(self, key)

    def __delitem__(self, key):
        return _libhfst.HfstSymbolPairSubstitutions___delitem__(self, key)

    def has_key(self, key):
        return _libhfst.HfstSymbolPairSubstitutions_has_key(self, key)

    def keys(self):
        return _libhfst.HfstSymbolPairSubstitutions_keys(self)

    def values(self):
        return _libhfst.HfstSymbolPairSubstitutions_values(self)

    def items(self):
        return _libhfst.HfstSymbolPairSubstitutions_items(self)

    def __contains__(self, key):
        return _libhfst.HfstSymbolPairSubstitutions___contains__(self, key)

    def key_iterator(self):
        return _libhfst.HfstSymbolPairSubstitutions_key_iterator(self)

    def value_iterator(self):
        return _libhfst.HfstSymbolPairSubstitutions_value_iterator(self)

    def __setitem__(self, *args):
        return _libhfst.HfstSymbolPairSubstitutions___setitem__(self, *args)

    def asdict(self):
        return _libhfst.HfstSymbolPairSubstitutions_asdict(self)

    def __init__(self, *args):
        _libhfst.HfstSymbolPairSubstitutions_swiginit(self, _libhfst.new_HfstSymbolPairSubstitutions(*args))

    def empty(self):
        return _libhfst.HfstSymbolPairSubstitutions_empty(self)

    def size(self):
        return _libhfst.HfstSymbolPairSubstitutions_size(self)

    def swap(self, v):
        return _libhfst.HfstSymbolPairSubstitutions_swap(self, v)

    def begin(self):
        return _libhfst.HfstSymbolPairSubstitutions_begin(self)

    def end(self):
        return _libhfst.HfstSymbolPairSubstitutions_end(self)

    def rbegin(self):
        return _libhfst.HfstSymbolPairSubstitutions_rbegin(self)

    def rend(self):
        return _libhfst.HfstSymbolPairSubstitutions_rend(self)

    def clear(self):
        return _libhfst.HfstSymbolPairSubstitutions_clear(self)

    def get_allocator(self):
        return _libhfst.HfstSymbolPairSubstitutions_get_allocator(self)

    def count(self, x):
        return _libhfst.HfstSymbolPairSubstitutions_count(self, x)

    def erase(self, *args):
        return _libhfst.HfstSymbolPairSubstitutions_erase(self, *args)

    def find(self, x):
        return _libhfst.HfstSymbolPairSubstitutions_find(self, x)

    def lower_bound(self, x):
        return _libhfst.HfstSymbolPairSubstitutions_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst.HfstSymbolPairSubstitutions_upper_bound(self, x)
    __swig_destroy__ = _libhfst.delete_HfstSymbolPairSubstitutions

# Register HfstSymbolPairSubstitutions in _libhfst:
_libhfst.HfstSymbolPairSubstitutions_swigregister(HfstSymbolPairSubstitutions)

class BarBazFoo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.BarBazFoo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.BarBazFoo___nonzero__(self)

    def __bool__(self):
        return _libhfst.BarBazFoo___bool__(self)

    def __len__(self):
        return _libhfst.BarBazFoo___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.BarBazFoo___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.BarBazFoo___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.BarBazFoo___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.BarBazFoo___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.BarBazFoo___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.BarBazFoo___setitem__(self, *args)

    def pop(self):
        return _libhfst.BarBazFoo_pop(self)

    def append(self, x):
        return _libhfst.BarBazFoo_append(self, x)

    def empty(self):
        return _libhfst.BarBazFoo_empty(self)

    def size(self):
        return _libhfst.BarBazFoo_size(self)

    def swap(self, v):
        return _libhfst.BarBazFoo_swap(self, v)

    def begin(self):
        return _libhfst.BarBazFoo_begin(self)

    def end(self):
        return _libhfst.BarBazFoo_end(self)

    def rbegin(self):
        return _libhfst.BarBazFoo_rbegin(self)

    def rend(self):
        return _libhfst.BarBazFoo_rend(self)

    def clear(self):
        return _libhfst.BarBazFoo_clear(self)

    def get_allocator(self):
        return _libhfst.BarBazFoo_get_allocator(self)

    def pop_back(self):
        return _libhfst.BarBazFoo_pop_back(self)

    def erase(self, *args):
        return _libhfst.BarBazFoo_erase(self, *args)

    def __init__(self, *args):
        _libhfst.BarBazFoo_swiginit(self, _libhfst.new_BarBazFoo(*args))

    def push_back(self, x):
        return _libhfst.BarBazFoo_push_back(self, x)

    def front(self):
        return _libhfst.BarBazFoo_front(self)

    def back(self):
        return _libhfst.BarBazFoo_back(self)

    def assign(self, n, x):
        return _libhfst.BarBazFoo_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.BarBazFoo_resize(self, *args)

    def insert(self, *args):
        return _libhfst.BarBazFoo_insert(self, *args)

    def reserve(self, n):
        return _libhfst.BarBazFoo_reserve(self, n)

    def capacity(self):
        return _libhfst.BarBazFoo_capacity(self)
    __swig_destroy__ = _libhfst.delete_BarBazFoo

# Register BarBazFoo in _libhfst:
_libhfst.BarBazFoo_swigregister(BarBazFoo)

class HfstBasicTransitions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstBasicTransitions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstBasicTransitions___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstBasicTransitions___bool__(self)

    def __len__(self):
        return _libhfst.HfstBasicTransitions___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.HfstBasicTransitions___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.HfstBasicTransitions___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.HfstBasicTransitions___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.HfstBasicTransitions___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.HfstBasicTransitions___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.HfstBasicTransitions___setitem__(self, *args)

    def pop(self):
        return _libhfst.HfstBasicTransitions_pop(self)

    def append(self, x):
        return _libhfst.HfstBasicTransitions_append(self, x)

    def empty(self):
        return _libhfst.HfstBasicTransitions_empty(self)

    def size(self):
        return _libhfst.HfstBasicTransitions_size(self)

    def swap(self, v):
        return _libhfst.HfstBasicTransitions_swap(self, v)

    def begin(self):
        return _libhfst.HfstBasicTransitions_begin(self)

    def end(self):
        return _libhfst.HfstBasicTransitions_end(self)

    def rbegin(self):
        return _libhfst.HfstBasicTransitions_rbegin(self)

    def rend(self):
        return _libhfst.HfstBasicTransitions_rend(self)

    def clear(self):
        return _libhfst.HfstBasicTransitions_clear(self)

    def get_allocator(self):
        return _libhfst.HfstBasicTransitions_get_allocator(self)

    def pop_back(self):
        return _libhfst.HfstBasicTransitions_pop_back(self)

    def erase(self, *args):
        return _libhfst.HfstBasicTransitions_erase(self, *args)

    def __init__(self, *args):
        _libhfst.HfstBasicTransitions_swiginit(self, _libhfst.new_HfstBasicTransitions(*args))

    def push_back(self, x):
        return _libhfst.HfstBasicTransitions_push_back(self, x)

    def front(self):
        return _libhfst.HfstBasicTransitions_front(self)

    def back(self):
        return _libhfst.HfstBasicTransitions_back(self)

    def assign(self, n, x):
        return _libhfst.HfstBasicTransitions_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.HfstBasicTransitions_resize(self, *args)

    def insert(self, *args):
        return _libhfst.HfstBasicTransitions_insert(self, *args)

    def reserve(self, n):
        return _libhfst.HfstBasicTransitions_reserve(self, n)

    def capacity(self):
        return _libhfst.HfstBasicTransitions_capacity(self)
    __swig_destroy__ = _libhfst.delete_HfstBasicTransitions

# Register HfstBasicTransitions in _libhfst:
_libhfst.HfstBasicTransitions_swigregister(HfstBasicTransitions)

class HfstOneLevelPath(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstOneLevelPath_swiginit(self, _libhfst.new_HfstOneLevelPath(*args))
    first = property(_libhfst.HfstOneLevelPath_first_get, _libhfst.HfstOneLevelPath_first_set)
    second = property(_libhfst.HfstOneLevelPath_second_get, _libhfst.HfstOneLevelPath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst.delete_HfstOneLevelPath

# Register HfstOneLevelPath in _libhfst:
_libhfst.HfstOneLevelPath_swigregister(HfstOneLevelPath)

class HfstOneLevelPaths(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstOneLevelPaths_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstOneLevelPaths___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstOneLevelPaths___bool__(self)

    def __len__(self):
        return _libhfst.HfstOneLevelPaths___len__(self)

    def append(self, x):
        return _libhfst.HfstOneLevelPaths_append(self, x)

    def __contains__(self, x):
        return _libhfst.HfstOneLevelPaths___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst.HfstOneLevelPaths___getitem__(self, i)

    def add(self, x):
        return _libhfst.HfstOneLevelPaths_add(self, x)

    def discard(self, x):
        return _libhfst.HfstOneLevelPaths_discard(self, x)

    def __init__(self, *args):
        _libhfst.HfstOneLevelPaths_swiginit(self, _libhfst.new_HfstOneLevelPaths(*args))

    def empty(self):
        return _libhfst.HfstOneLevelPaths_empty(self)

    def size(self):
        return _libhfst.HfstOneLevelPaths_size(self)

    def clear(self):
        return _libhfst.HfstOneLevelPaths_clear(self)

    def swap(self, v):
        return _libhfst.HfstOneLevelPaths_swap(self, v)

    def count(self, x):
        return _libhfst.HfstOneLevelPaths_count(self, x)

    def begin(self):
        return _libhfst.HfstOneLevelPaths_begin(self)

    def end(self):
        return _libhfst.HfstOneLevelPaths_end(self)

    def rbegin(self):
        return _libhfst.HfstOneLevelPaths_rbegin(self)

    def rend(self):
        return _libhfst.HfstOneLevelPaths_rend(self)

    def erase(self, *args):
        return _libhfst.HfstOneLevelPaths_erase(self, *args)

    def find(self, x):
        return _libhfst.HfstOneLevelPaths_find(self, x)

    def lower_bound(self, x):
        return _libhfst.HfstOneLevelPaths_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst.HfstOneLevelPaths_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst.HfstOneLevelPaths_equal_range(self, x)

    def insert(self, __x):
        return _libhfst.HfstOneLevelPaths_insert(self, __x)
    __swig_destroy__ = _libhfst.delete_HfstOneLevelPaths

# Register HfstOneLevelPaths in _libhfst:
_libhfst.HfstOneLevelPaths_swigregister(HfstOneLevelPaths)

class HfstTwoLevelPath(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstTwoLevelPath_swiginit(self, _libhfst.new_HfstTwoLevelPath(*args))
    first = property(_libhfst.HfstTwoLevelPath_first_get, _libhfst.HfstTwoLevelPath_first_set)
    second = property(_libhfst.HfstTwoLevelPath_second_get, _libhfst.HfstTwoLevelPath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst.delete_HfstTwoLevelPath

# Register HfstTwoLevelPath in _libhfst:
_libhfst.HfstTwoLevelPath_swigregister(HfstTwoLevelPath)

class HfstTwoLevelPaths(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstTwoLevelPaths_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstTwoLevelPaths___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstTwoLevelPaths___bool__(self)

    def __len__(self):
        return _libhfst.HfstTwoLevelPaths___len__(self)

    def append(self, x):
        return _libhfst.HfstTwoLevelPaths_append(self, x)

    def __contains__(self, x):
        return _libhfst.HfstTwoLevelPaths___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst.HfstTwoLevelPaths___getitem__(self, i)

    def add(self, x):
        return _libhfst.HfstTwoLevelPaths_add(self, x)

    def discard(self, x):
        return _libhfst.HfstTwoLevelPaths_discard(self, x)

    def __init__(self, *args):
        _libhfst.HfstTwoLevelPaths_swiginit(self, _libhfst.new_HfstTwoLevelPaths(*args))

    def empty(self):
        return _libhfst.HfstTwoLevelPaths_empty(self)

    def size(self):
        return _libhfst.HfstTwoLevelPaths_size(self)

    def clear(self):
        return _libhfst.HfstTwoLevelPaths_clear(self)

    def swap(self, v):
        return _libhfst.HfstTwoLevelPaths_swap(self, v)

    def count(self, x):
        return _libhfst.HfstTwoLevelPaths_count(self, x)

    def begin(self):
        return _libhfst.HfstTwoLevelPaths_begin(self)

    def end(self):
        return _libhfst.HfstTwoLevelPaths_end(self)

    def rbegin(self):
        return _libhfst.HfstTwoLevelPaths_rbegin(self)

    def rend(self):
        return _libhfst.HfstTwoLevelPaths_rend(self)

    def erase(self, *args):
        return _libhfst.HfstTwoLevelPaths_erase(self, *args)

    def find(self, x):
        return _libhfst.HfstTwoLevelPaths_find(self, x)

    def lower_bound(self, x):
        return _libhfst.HfstTwoLevelPaths_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst.HfstTwoLevelPaths_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst.HfstTwoLevelPaths_equal_range(self, x)

    def insert(self, __x):
        return _libhfst.HfstTwoLevelPaths_insert(self, __x)
    __swig_destroy__ = _libhfst.delete_HfstTwoLevelPaths

# Register HfstTwoLevelPaths in _libhfst:
_libhfst.HfstTwoLevelPaths_swigregister(HfstTwoLevelPaths)

class HfstTransducerPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstTransducerPair_swiginit(self, _libhfst.new_HfstTransducerPair(*args))
    first = property(_libhfst.HfstTransducerPair_first_get, _libhfst.HfstTransducerPair_first_set)
    second = property(_libhfst.HfstTransducerPair_second_get, _libhfst.HfstTransducerPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst.delete_HfstTransducerPair

# Register HfstTransducerPair in _libhfst:
_libhfst.HfstTransducerPair_swigregister(HfstTransducerPair)

class HfstTransducerPairVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstTransducerPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstTransducerPairVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstTransducerPairVector___bool__(self)

    def __len__(self):
        return _libhfst.HfstTransducerPairVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.HfstTransducerPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.HfstTransducerPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.HfstTransducerPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.HfstTransducerPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.HfstTransducerPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.HfstTransducerPairVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.HfstTransducerPairVector_pop(self)

    def append(self, x):
        return _libhfst.HfstTransducerPairVector_append(self, x)

    def empty(self):
        return _libhfst.HfstTransducerPairVector_empty(self)

    def size(self):
        return _libhfst.HfstTransducerPairVector_size(self)

    def swap(self, v):
        return _libhfst.HfstTransducerPairVector_swap(self, v)

    def begin(self):
        return _libhfst.HfstTransducerPairVector_begin(self)

    def end(self):
        return _libhfst.HfstTransducerPairVector_end(self)

    def rbegin(self):
        return _libhfst.HfstTransducerPairVector_rbegin(self)

    def rend(self):
        return _libhfst.HfstTransducerPairVector_rend(self)

    def clear(self):
        return _libhfst.HfstTransducerPairVector_clear(self)

    def get_allocator(self):
        return _libhfst.HfstTransducerPairVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.HfstTransducerPairVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.HfstTransducerPairVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.HfstTransducerPairVector_swiginit(self, _libhfst.new_HfstTransducerPairVector(*args))

    def push_back(self, x):
        return _libhfst.HfstTransducerPairVector_push_back(self, x)

    def front(self):
        return _libhfst.HfstTransducerPairVector_front(self)

    def back(self):
        return _libhfst.HfstTransducerPairVector_back(self)

    def assign(self, n, x):
        return _libhfst.HfstTransducerPairVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.HfstTransducerPairVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.HfstTransducerPairVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.HfstTransducerPairVector_reserve(self, n)

    def capacity(self):
        return _libhfst.HfstTransducerPairVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_HfstTransducerPairVector

# Register HfstTransducerPairVector in _libhfst:
_libhfst.HfstTransducerPairVector_swigregister(HfstTransducerPairVector)

class HfstRuleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.HfstRuleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.HfstRuleVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.HfstRuleVector___bool__(self)

    def __len__(self):
        return _libhfst.HfstRuleVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.HfstRuleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.HfstRuleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.HfstRuleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.HfstRuleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.HfstRuleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.HfstRuleVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.HfstRuleVector_pop(self)

    def append(self, x):
        return _libhfst.HfstRuleVector_append(self, x)

    def empty(self):
        return _libhfst.HfstRuleVector_empty(self)

    def size(self):
        return _libhfst.HfstRuleVector_size(self)

    def swap(self, v):
        return _libhfst.HfstRuleVector_swap(self, v)

    def begin(self):
        return _libhfst.HfstRuleVector_begin(self)

    def end(self):
        return _libhfst.HfstRuleVector_end(self)

    def rbegin(self):
        return _libhfst.HfstRuleVector_rbegin(self)

    def rend(self):
        return _libhfst.HfstRuleVector_rend(self)

    def clear(self):
        return _libhfst.HfstRuleVector_clear(self)

    def get_allocator(self):
        return _libhfst.HfstRuleVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.HfstRuleVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.HfstRuleVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.HfstRuleVector_swiginit(self, _libhfst.new_HfstRuleVector(*args))

    def push_back(self, x):
        return _libhfst.HfstRuleVector_push_back(self, x)

    def front(self):
        return _libhfst.HfstRuleVector_front(self)

    def back(self):
        return _libhfst.HfstRuleVector_back(self)

    def assign(self, n, x):
        return _libhfst.HfstRuleVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.HfstRuleVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.HfstRuleVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.HfstRuleVector_reserve(self, n)

    def capacity(self):
        return _libhfst.HfstRuleVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_HfstRuleVector

# Register HfstRuleVector in _libhfst:
_libhfst.HfstRuleVector_swigregister(HfstRuleVector)

class HfstTransducerUIntPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstTransducerUIntPair_swiginit(self, _libhfst.new_HfstTransducerUIntPair(*args))
    first = property(_libhfst.HfstTransducerUIntPair_first_get, _libhfst.HfstTransducerUIntPair_first_set)
    second = property(_libhfst.HfstTransducerUIntPair_second_get, _libhfst.HfstTransducerUIntPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst.delete_HfstTransducerUIntPair

# Register HfstTransducerUIntPair in _libhfst:
_libhfst.HfstTransducerUIntPair_swigregister(HfstTransducerUIntPair)

class LocationVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.LocationVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.LocationVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.LocationVector___bool__(self)

    def __len__(self):
        return _libhfst.LocationVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.LocationVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.LocationVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.LocationVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.LocationVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.LocationVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.LocationVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.LocationVector_pop(self)

    def append(self, x):
        return _libhfst.LocationVector_append(self, x)

    def empty(self):
        return _libhfst.LocationVector_empty(self)

    def size(self):
        return _libhfst.LocationVector_size(self)

    def swap(self, v):
        return _libhfst.LocationVector_swap(self, v)

    def begin(self):
        return _libhfst.LocationVector_begin(self)

    def end(self):
        return _libhfst.LocationVector_end(self)

    def rbegin(self):
        return _libhfst.LocationVector_rbegin(self)

    def rend(self):
        return _libhfst.LocationVector_rend(self)

    def clear(self):
        return _libhfst.LocationVector_clear(self)

    def get_allocator(self):
        return _libhfst.LocationVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.LocationVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.LocationVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.LocationVector_swiginit(self, _libhfst.new_LocationVector(*args))

    def push_back(self, x):
        return _libhfst.LocationVector_push_back(self, x)

    def front(self):
        return _libhfst.LocationVector_front(self)

    def back(self):
        return _libhfst.LocationVector_back(self)

    def assign(self, n, x):
        return _libhfst.LocationVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.LocationVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.LocationVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.LocationVector_reserve(self, n)

    def capacity(self):
        return _libhfst.LocationVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_LocationVector

# Register LocationVector in _libhfst:
_libhfst.LocationVector_swigregister(LocationVector)

class LocationVectorVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst.LocationVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst.LocationVectorVector___nonzero__(self)

    def __bool__(self):
        return _libhfst.LocationVectorVector___bool__(self)

    def __len__(self):
        return _libhfst.LocationVectorVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst.LocationVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst.LocationVectorVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst.LocationVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst.LocationVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst.LocationVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst.LocationVectorVector___setitem__(self, *args)

    def pop(self):
        return _libhfst.LocationVectorVector_pop(self)

    def append(self, x):
        return _libhfst.LocationVectorVector_append(self, x)

    def empty(self):
        return _libhfst.LocationVectorVector_empty(self)

    def size(self):
        return _libhfst.LocationVectorVector_size(self)

    def swap(self, v):
        return _libhfst.LocationVectorVector_swap(self, v)

    def begin(self):
        return _libhfst.LocationVectorVector_begin(self)

    def end(self):
        return _libhfst.LocationVectorVector_end(self)

    def rbegin(self):
        return _libhfst.LocationVectorVector_rbegin(self)

    def rend(self):
        return _libhfst.LocationVectorVector_rend(self)

    def clear(self):
        return _libhfst.LocationVectorVector_clear(self)

    def get_allocator(self):
        return _libhfst.LocationVectorVector_get_allocator(self)

    def pop_back(self):
        return _libhfst.LocationVectorVector_pop_back(self)

    def erase(self, *args):
        return _libhfst.LocationVectorVector_erase(self, *args)

    def __init__(self, *args):
        _libhfst.LocationVectorVector_swiginit(self, _libhfst.new_LocationVectorVector(*args))

    def push_back(self, x):
        return _libhfst.LocationVectorVector_push_back(self, x)

    def front(self):
        return _libhfst.LocationVectorVector_front(self)

    def back(self):
        return _libhfst.LocationVectorVector_back(self)

    def assign(self, n, x):
        return _libhfst.LocationVectorVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst.LocationVectorVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst.LocationVectorVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst.LocationVectorVector_reserve(self, n)

    def capacity(self):
        return _libhfst.LocationVectorVector_capacity(self)
    __swig_destroy__ = _libhfst.delete_LocationVectorVector

# Register LocationVectorVector in _libhfst:
_libhfst.LocationVectorVector_swigregister(LocationVectorVector)

class HfstException(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstException_swiginit(self, _libhfst.new_HfstException(*args))
    __swig_destroy__ = _libhfst.delete_HfstException

    def what(self):
        return _libhfst.HfstException_what(self)

# Register HfstException in _libhfst:
_libhfst.HfstException_swigregister(HfstException)

class HfstTransducerTypeMismatchException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.HfstTransducerTypeMismatchException_swiginit(self, _libhfst.new_HfstTransducerTypeMismatchException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_HfstTransducerTypeMismatchException

    def what(self):
        return _libhfst.HfstTransducerTypeMismatchException_what(self)

# Register HfstTransducerTypeMismatchException in _libhfst:
_libhfst.HfstTransducerTypeMismatchException_swigregister(HfstTransducerTypeMismatchException)

class ImplementationTypeNotAvailableException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4, type):
        _libhfst.ImplementationTypeNotAvailableException_swiginit(self, _libhfst.new_ImplementationTypeNotAvailableException(arg2, arg3, arg4, type))
    __swig_destroy__ = _libhfst.delete_ImplementationTypeNotAvailableException

    def what(self):
        return _libhfst.ImplementationTypeNotAvailableException_what(self)

    def get_type(self):
        return _libhfst.ImplementationTypeNotAvailableException_get_type(self)

# Register ImplementationTypeNotAvailableException in _libhfst:
_libhfst.ImplementationTypeNotAvailableException_swigregister(ImplementationTypeNotAvailableException)

class FunctionNotImplementedException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.FunctionNotImplementedException_swiginit(self, _libhfst.new_FunctionNotImplementedException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_FunctionNotImplementedException

    def what(self):
        return _libhfst.FunctionNotImplementedException_what(self)

# Register FunctionNotImplementedException in _libhfst:
_libhfst.FunctionNotImplementedException_swigregister(FunctionNotImplementedException)

class StreamNotReadableException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.StreamNotReadableException_swiginit(self, _libhfst.new_StreamNotReadableException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_StreamNotReadableException

    def what(self):
        return _libhfst.StreamNotReadableException_what(self)

# Register StreamNotReadableException in _libhfst:
_libhfst.StreamNotReadableException_swigregister(StreamNotReadableException)

class StreamCannotBeWrittenException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.StreamCannotBeWrittenException_swiginit(self, _libhfst.new_StreamCannotBeWrittenException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_StreamCannotBeWrittenException

    def what(self):
        return _libhfst.StreamCannotBeWrittenException_what(self)

# Register StreamCannotBeWrittenException in _libhfst:
_libhfst.StreamCannotBeWrittenException_swigregister(StreamCannotBeWrittenException)

class StreamIsClosedException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.StreamIsClosedException_swiginit(self, _libhfst.new_StreamIsClosedException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_StreamIsClosedException

    def what(self):
        return _libhfst.StreamIsClosedException_what(self)

# Register StreamIsClosedException in _libhfst:
_libhfst.StreamIsClosedException_swigregister(StreamIsClosedException)

class EndOfStreamException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.EndOfStreamException_swiginit(self, _libhfst.new_EndOfStreamException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_EndOfStreamException

    def what(self):
        return _libhfst.EndOfStreamException_what(self)

# Register EndOfStreamException in _libhfst:
_libhfst.EndOfStreamException_swigregister(EndOfStreamException)

class TransducerIsCyclicException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.TransducerIsCyclicException_swiginit(self, _libhfst.new_TransducerIsCyclicException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_TransducerIsCyclicException

    def what(self):
        return _libhfst.TransducerIsCyclicException_what(self)

# Register TransducerIsCyclicException in _libhfst:
_libhfst.TransducerIsCyclicException_swigregister(TransducerIsCyclicException)

class NotTransducerStreamException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.NotTransducerStreamException_swiginit(self, _libhfst.new_NotTransducerStreamException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_NotTransducerStreamException

    def what(self):
        return _libhfst.NotTransducerStreamException_what(self)

# Register NotTransducerStreamException in _libhfst:
_libhfst.NotTransducerStreamException_swigregister(NotTransducerStreamException)

class NotValidAttFormatException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.NotValidAttFormatException_swiginit(self, _libhfst.new_NotValidAttFormatException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_NotValidAttFormatException

    def what(self):
        return _libhfst.NotValidAttFormatException_what(self)

# Register NotValidAttFormatException in _libhfst:
_libhfst.NotValidAttFormatException_swigregister(NotValidAttFormatException)

class NotValidPrologFormatException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.NotValidPrologFormatException_swiginit(self, _libhfst.new_NotValidPrologFormatException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_NotValidPrologFormatException

    def what(self):
        return _libhfst.NotValidPrologFormatException_what(self)

# Register NotValidPrologFormatException in _libhfst:
_libhfst.NotValidPrologFormatException_swigregister(NotValidPrologFormatException)

class NotValidLexcFormatException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.NotValidLexcFormatException_swiginit(self, _libhfst.new_NotValidLexcFormatException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_NotValidLexcFormatException

    def what(self):
        return _libhfst.NotValidLexcFormatException_what(self)

# Register NotValidLexcFormatException in _libhfst:
_libhfst.NotValidLexcFormatException_swigregister(NotValidLexcFormatException)

class StateIsNotFinalException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.StateIsNotFinalException_swiginit(self, _libhfst.new_StateIsNotFinalException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_StateIsNotFinalException

    def what(self):
        return _libhfst.StateIsNotFinalException_what(self)

# Register StateIsNotFinalException in _libhfst:
_libhfst.StateIsNotFinalException_swigregister(StateIsNotFinalException)

class ContextTransducersAreNotAutomataException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.ContextTransducersAreNotAutomataException_swiginit(self, _libhfst.new_ContextTransducersAreNotAutomataException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_ContextTransducersAreNotAutomataException

    def what(self):
        return _libhfst.ContextTransducersAreNotAutomataException_what(self)

# Register ContextTransducersAreNotAutomataException in _libhfst:
_libhfst.ContextTransducersAreNotAutomataException_swigregister(ContextTransducersAreNotAutomataException)

class TransducersAreNotAutomataException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.TransducersAreNotAutomataException_swiginit(self, _libhfst.new_TransducersAreNotAutomataException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_TransducersAreNotAutomataException

    def what(self):
        return _libhfst.TransducersAreNotAutomataException_what(self)

# Register TransducersAreNotAutomataException in _libhfst:
_libhfst.TransducersAreNotAutomataException_swigregister(TransducersAreNotAutomataException)

class StateIndexOutOfBoundsException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.StateIndexOutOfBoundsException_swiginit(self, _libhfst.new_StateIndexOutOfBoundsException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_StateIndexOutOfBoundsException

    def what(self):
        return _libhfst.StateIndexOutOfBoundsException_what(self)

# Register StateIndexOutOfBoundsException in _libhfst:
_libhfst.StateIndexOutOfBoundsException_swigregister(StateIndexOutOfBoundsException)

class TransducerHeaderException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.TransducerHeaderException_swiginit(self, _libhfst.new_TransducerHeaderException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_TransducerHeaderException

    def what(self):
        return _libhfst.TransducerHeaderException_what(self)

# Register TransducerHeaderException in _libhfst:
_libhfst.TransducerHeaderException_swigregister(TransducerHeaderException)

class MissingOpenFstInputSymbolTableException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.MissingOpenFstInputSymbolTableException_swiginit(self, _libhfst.new_MissingOpenFstInputSymbolTableException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_MissingOpenFstInputSymbolTableException

    def what(self):
        return _libhfst.MissingOpenFstInputSymbolTableException_what(self)

# Register MissingOpenFstInputSymbolTableException in _libhfst:
_libhfst.MissingOpenFstInputSymbolTableException_swigregister(MissingOpenFstInputSymbolTableException)

class TransducerTypeMismatchException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.TransducerTypeMismatchException_swiginit(self, _libhfst.new_TransducerTypeMismatchException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_TransducerTypeMismatchException

    def what(self):
        return _libhfst.TransducerTypeMismatchException_what(self)

# Register TransducerTypeMismatchException in _libhfst:
_libhfst.TransducerTypeMismatchException_swigregister(TransducerTypeMismatchException)

class EmptySetOfContextsException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.EmptySetOfContextsException_swiginit(self, _libhfst.new_EmptySetOfContextsException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_EmptySetOfContextsException

    def what(self):
        return _libhfst.EmptySetOfContextsException_what(self)

# Register EmptySetOfContextsException in _libhfst:
_libhfst.EmptySetOfContextsException_swigregister(EmptySetOfContextsException)

class SpecifiedTypeRequiredException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.SpecifiedTypeRequiredException_swiginit(self, _libhfst.new_SpecifiedTypeRequiredException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_SpecifiedTypeRequiredException

    def what(self):
        return _libhfst.SpecifiedTypeRequiredException_what(self)

# Register SpecifiedTypeRequiredException in _libhfst:
_libhfst.SpecifiedTypeRequiredException_swigregister(SpecifiedTypeRequiredException)

class HfstFatalException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.HfstFatalException_swiginit(self, _libhfst.new_HfstFatalException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_HfstFatalException

    def what(self):
        return _libhfst.HfstFatalException_what(self)

# Register HfstFatalException in _libhfst:
_libhfst.HfstFatalException_swigregister(HfstFatalException)

class TransducerHasWrongTypeException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.TransducerHasWrongTypeException_swiginit(self, _libhfst.new_TransducerHasWrongTypeException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_TransducerHasWrongTypeException

    def what(self):
        return _libhfst.TransducerHasWrongTypeException_what(self)

# Register TransducerHasWrongTypeException in _libhfst:
_libhfst.TransducerHasWrongTypeException_swigregister(TransducerHasWrongTypeException)

class IncorrectUtf8CodingException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.IncorrectUtf8CodingException_swiginit(self, _libhfst.new_IncorrectUtf8CodingException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_IncorrectUtf8CodingException

    def what(self):
        return _libhfst.IncorrectUtf8CodingException_what(self)

# Register IncorrectUtf8CodingException in _libhfst:
_libhfst.IncorrectUtf8CodingException_swigregister(IncorrectUtf8CodingException)

class EmptyStringException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.EmptyStringException_swiginit(self, _libhfst.new_EmptyStringException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_EmptyStringException

    def what(self):
        return _libhfst.EmptyStringException_what(self)

# Register EmptyStringException in _libhfst:
_libhfst.EmptyStringException_swigregister(EmptyStringException)

class SymbolNotFoundException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.SymbolNotFoundException_swiginit(self, _libhfst.new_SymbolNotFoundException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_SymbolNotFoundException

    def what(self):
        return _libhfst.SymbolNotFoundException_what(self)

# Register SymbolNotFoundException in _libhfst:
_libhfst.SymbolNotFoundException_swigregister(SymbolNotFoundException)

class MetadataException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.MetadataException_swiginit(self, _libhfst.new_MetadataException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_MetadataException

    def what(self):
        return _libhfst.MetadataException_what(self)

# Register MetadataException in _libhfst:
_libhfst.MetadataException_swigregister(MetadataException)

class FlagDiacriticsAreNotIdentitiesException(HfstException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        _libhfst.FlagDiacriticsAreNotIdentitiesException_swiginit(self, _libhfst.new_FlagDiacriticsAreNotIdentitiesException(arg2, arg3, arg4))
    __swig_destroy__ = _libhfst.delete_FlagDiacriticsAreNotIdentitiesException

    def what(self):
        return _libhfst.FlagDiacriticsAreNotIdentitiesException_what(self)

# Register FlagDiacriticsAreNotIdentitiesException in _libhfst:
_libhfst.FlagDiacriticsAreNotIdentitiesException_swigregister(FlagDiacriticsAreNotIdentitiesException)

class Location(object):
    r"""

    Location of a pmatch result.

    Attributes:

        start:                  start index of match
        length:                 length of match
        input:                  the matched input string
        output:                 the matching output string
        tag:                    the tag of match
        weight:                 the weight of match
        input_parts:            tuple of indices in input_symbol_strings
        output_string:          tuple of indices in output_symbol_strings
        input_symbol_strings:   tuple of matched input symbol strings
        output_symbol_strings:  tuple of matching output symbol strings

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    start = property(_libhfst.Location_start_get, _libhfst.Location_start_set)
    length = property(_libhfst.Location_length_get, _libhfst.Location_length_set)
    input = property(_libhfst.Location_input_get, _libhfst.Location_input_set)
    output = property(_libhfst.Location_output_get, _libhfst.Location_output_set)
    tag = property(_libhfst.Location_tag_get, _libhfst.Location_tag_set)
    weight = property(_libhfst.Location_weight_get, _libhfst.Location_weight_set)
    input_parts = property(_libhfst.Location_input_parts_get, _libhfst.Location_input_parts_set)
    output_parts = property(_libhfst.Location_output_parts_get, _libhfst.Location_output_parts_set)
    input_symbol_strings = property(_libhfst.Location_input_symbol_strings_get, _libhfst.Location_input_symbol_strings_set)
    output_symbol_strings = property(_libhfst.Location_output_symbol_strings_get, _libhfst.Location_output_symbol_strings_set)

    def __init__(self):
        _libhfst.Location_swiginit(self, _libhfst.new_Location())
    __swig_destroy__ = _libhfst.delete_Location

# Register Location in _libhfst:
_libhfst.Location_swigregister(Location)

SFST_TYPE = _libhfst.SFST_TYPE
TROPICAL_OPENFST_TYPE = _libhfst.TROPICAL_OPENFST_TYPE
LOG_OPENFST_TYPE = _libhfst.LOG_OPENFST_TYPE
FOMA_TYPE = _libhfst.FOMA_TYPE
XFSM_TYPE = _libhfst.XFSM_TYPE
HFST_OL_TYPE = _libhfst.HFST_OL_TYPE
HFST_OLW_TYPE = _libhfst.HFST_OLW_TYPE
HFST2_TYPE = _libhfst.HFST2_TYPE
UNSPECIFIED_TYPE = _libhfst.UNSPECIFIED_TYPE
ERROR_TYPE = _libhfst.ERROR_TYPE
REPL_UP = _libhfst.REPL_UP
REPL_DOWN = _libhfst.REPL_DOWN
REPL_RIGHT = _libhfst.REPL_RIGHT
REPL_LEFT = _libhfst.REPL_LEFT
class Rule(object):
    r"""

    todo

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.Rule_swiginit(self, _libhfst.new_Rule(*args))

    def get_mapping(self):
        return _libhfst.Rule_get_mapping(self)

    def get_context(self):
        return _libhfst.Rule_get_context(self)

    def get_replType(self):
        return _libhfst.Rule_get_replType(self)

    def encodeFlags(self):
        return _libhfst.Rule_encodeFlags(self)
    __swig_destroy__ = _libhfst.delete_Rule

# Register Rule in _libhfst:
_libhfst.Rule_swigregister(Rule)


def replace(*args):
    r"""

    todo

    """
    return _libhfst.replace(*args)

def xerox_replace_left(*args):
    return _libhfst.xerox_replace_left(*args)

def replace_leftmost_longest_match(*args):
    r"""

    todo

    """
    return _libhfst.replace_leftmost_longest_match(*args)

def replace_rightmost_longest_match(*args):
    r"""

    todo

    """
    return _libhfst.replace_rightmost_longest_match(*args)

def replace_leftmost_shortest_match(*args):
    r"""

    todo

    """
    return _libhfst.replace_leftmost_shortest_match(*args)

def replace_rightmost_shortest_match(*args):
    r"""

    todo

    """
    return _libhfst.replace_rightmost_shortest_match(*args)

def replace_epenthesis(*args):
    r"""

    todo

    """
    return _libhfst.replace_epenthesis(*args)

def xerox_restriction(automata, context):
    return _libhfst.xerox_restriction(automata, context)

def before(left, right):
    r"""

    todo

    """
    return _libhfst.before(left, right)

def after(left, right):
    r"""

    todo

    """
    return _libhfst.after(left, right)

def is_diacritic(symbol):
    r"""


    Whether symbol *symbol* is a flag diacritic.

    Flag diacritics are of the form

         @[PNDRCU][.][A-Z]+([.][A-Z]+)?@

    """
    return _libhfst.is_diacritic(symbol)

def compile_pmatch_expression(pmatch):
    r"""


    Compile a pmatch expression into a tuple of transducers.

    Parameters
    ----------
    * `expr` :
        A string defining how pmatch is done.

    See also: hfst.compile_pmatch_file

    """
    return _libhfst.compile_pmatch_expression(pmatch)

def _is_string(s):
    if isinstance(s, str):
       return True
    else:
      return False
def _is_string_pair(sp):
    if not isinstance(sp, tuple):
       return False
    if len(sp) != 2:
       return False
    if not _is_string(sp[0]):
       return False
    if not _is_string(sp[1]):
       return False
    return True
def _is_string_vector(sv):
    if not isinstance(sv, tuple):
       return False
    for s in sv:
        if not _is_string(s):
           return False
    return True
def _is_string_pair_vector(spv):
    if not isinstance(spv, tuple):
       return False
    for sp in spv:
        if not _is_string_pair(sp):
           return False
    return True

def _two_level_paths_to_dict(tlps):
    retval = {}
    for tlp in tlps:
        input = ""
        output = ""
        for sp in tlp[1]:
            input += sp[0]
            output += sp[1]
        if input in retval:
            retval[input].append((output, tlp[0]))
        else:
            retval[input] = [(output, tlp[0])]
    return retval

def _one_level_paths_to_tuple(olps):
    retval = []
    for olp in olps:
        path = ""
        for s in olp[1]:
            path += s
        retval.append((path, olp[0]))
    return tuple(retval)

class HfstTransducer(object):
    r"""


    A synchronous finite-state transducer.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def set_name(self, name):
        r"""


        Rename the transducer *name*.

        Parameters
        ----------
        * `name` :
            The name of the transducer.

        See also: get_name

        """
        return _libhfst.HfstTransducer_set_name(self, name)

    def get_name(self):
        r"""


        Get the name of the transducer.

        See also: set_name

        """
        return _libhfst.HfstTransducer_get_name(self)

    def get_type(self):
        r"""


        The implementation type of the transducer.

        Returns
        -------
        hfst.ImplementationType

        """
        return _libhfst.HfstTransducer_get_type(self)

    def set_property(self, property, value):
        r"""


        Set arbitrary string property *property* to *value*.

        Parameters
        ----------
        * `property` :
            A string naming the property.
        * `value` :
            A string expressing the value of *property*.

        set_property('name', 'name of the transducer') equals set_name('name of the
        transducer').

        note: While this function is capable of creating endless amounts of arbitrary
            metadata, it is suggested that property names are drawn from central
            repository, or prefixed with "x-". A property that does not follow this
            convention may affect the behavior of transducer in future releases.

        """
        return _libhfst.HfstTransducer_set_property(self, property, value)

    def get_property(self, property):
        r"""


        Get arbitrary string propert *property*.

        Parameters
        ----------
        * `property` :
            The name of the property whose value is returned. get_property('name') works
            like get_name().

        """
        return _libhfst.HfstTransducer_get_property(self, property)

    def get_properties(self):
        r"""


        Get all properties from the transducer.

        Returns
        -------
        A dictionary whose keys are properties and whose values are the values of those
        properties.

        """
        return _libhfst.HfstTransducer_get_properties(self)

    def compare(self, arg2, harmonize=True):
        r"""


        Whether this transducer and *another* are equivalent.

        Parameters
        ----------
        * `another` :
            The compared transducer.

        pre: *self* and *another* must have the same implementation type.

        Two transducers are equivalent iff they accept the same input/output string
        pairs with the same weights and the same alignments.

        note: For weighted transducers, the function often returns false negatives due
            to weight precision issues.

        """
        return _libhfst.HfstTransducer_compare(self, arg2, harmonize)

    def number_of_states(self):
        r"""


        The number of states in the transducer.

        """
        return _libhfst.HfstTransducer_number_of_states(self)

    def number_of_arcs(self):
        r"""


        The number of transitions in the transducer.

        """
        return _libhfst.HfstTransducer_number_of_arcs(self)

    def get_alphabet(self):
        r"""


        Get the alphabet of the transducer.

        The alphabet is defined as the set of symbols known to the transducer.

        Returns
        -------
        A tuple of strings.

        """
        return _libhfst.HfstTransducer_get_alphabet(self)

    def is_cyclic(self):
        r"""


        Whether the transducer is cyclic.

        """
        return _libhfst.HfstTransducer_is_cyclic(self)

    def is_automaton(self):
        r"""


        Whether each transition in the transducer has equivalent input and output
        symbols.

        note: Transition with hfst.UNKNOWN on both sides IS NOT a transition with
            equivalent input and output symbols.

        note: Transition with hfst.IDENTITY on both sides IS a transition with
            equivalent input and output symbols.

        """
        return _libhfst.HfstTransducer_is_automaton(self)

    def is_infinitely_ambiguous(self):
        r"""


        Whether the transducer is infinitely ambiguous.

        A transducer is infinitely ambiguous if there exists an input that will yield
        infinitely many results, i.e. there are input epsilon loops that are traversed
        with that input.

        """
        return _libhfst.HfstTransducer_is_infinitely_ambiguous(self)

    def is_lookup_infinitely_ambiguous(self, arg2):
        r"""


        Whether lookup of path *input* will have infinite results.

        Currently, this function will return whether the transducer is infinitely
        ambiguous on any lookup path found in the transducer, i.e. the argument *input*
        is ignored.

        Todo
        Do not ignore the argument *input*

        """
        return _libhfst.HfstTransducer_is_lookup_infinitely_ambiguous(self, arg2)

    def has_flag_diacritics(self):
        r"""


        Whether the transducer has flag diacritics in its transitions.

        """
        return _libhfst.HfstTransducer_has_flag_diacritics(self)

    def insert_to_alphabet(self, arg2):
        r"""


        Explicitly insert *symbol* to the alphabet of the transducer.

        Parameters
        ----------
        * `symbol` :
            The symbol (string) to be inserted.

        note: Usually this function is not needed since new symbols are added to the
            alphabet by default.

        """
        return _libhfst.HfstTransducer_insert_to_alphabet(self, arg2)

    def remove_from_alphabet(self, arg2):
        r"""


        Remove *symbol* from the alphabet of the transducer.

        Parameters
        ----------
        * `symbol` :
            The symbol (string) to be removed.

        pre: *symbol* does not occur in any transition of the transducer.

        note: Use with care, removing a symbol that occurs in a transition of the
            transducer can have unexpected results.

        """
        return _libhfst.HfstTransducer_remove_from_alphabet(self, arg2)

    @staticmethod
    def is_implementation_type_available(type):
        r"""


        Whether HFST is linked to the transducer library needed by implementation type
        *type*.

        """
        return _libhfst.HfstTransducer_is_implementation_type_available(type)

    def longest_path_size(self, obey_flags=True):
        r"""


        Get length of longest path of the transducer.

        """
        return _libhfst.HfstTransducer_longest_path_size(self, obey_flags)

    def concatenate(self, tr, harmonize=True):
        r"""


        Concatenate this transducer with *another*.

        """
        return _libhfst.HfstTransducer_concatenate(self, tr, harmonize)

    def disjunct(self, tr, harmonize=True):
        r"""


        Disjunct this transducer with *another*.

        """
        return _libhfst.HfstTransducer_disjunct(self, tr, harmonize)

    def subtract(self, tr, harmonize=True):
        r"""


        Subtract transducer *another* from this transducer.

        """
        return _libhfst.HfstTransducer_subtract(self, tr, harmonize)

    def intersect(self, tr, harmonize=True):
        r"""


        Intersect this transducer with *another*.

        """
        return _libhfst.HfstTransducer_intersect(self, tr, harmonize)

    def compose(self, tr, harmonize=True):
        r"""


        Compose this transducer with *another*.

        Parameters
        ----------
        * `another` :
            The second argument in the composition. Not modified.

        """
        return _libhfst.HfstTransducer_compose(self, tr, harmonize)

    def compose_intersect(self, v, invert=False, harmonize=True):
        r"""


        Compose this transducer with the intersection of transducers in *v*.

        If *invert* is true, then compose the intersection of the transducers in *v*
        with this transducer.

        The algorithm used by this function is faster than intersecting all transducers
        one by one and then composing this transducer with the intersection.

        pre: The transducers in *v* are deterministic and epsilon-free.

        Parameters
        ----------
        * `v` :
            A tuple of transducers.
        * `invert` :
            Whether the intersection of the transducers in *v* is composed with this
            transducer.

        """
        return _libhfst.HfstTransducer_compose_intersect(self, v, invert, harmonize)

    def priority_union(self, another):
        r"""


        Make priority union of this transducer with *another*.

        For the operation t1.priority_union(t2), the result is a union of t1 and t2,
        except that whenever t1 and t2 have the same string on left side, the path in t2
        overrides the path in t1.

        Example

             Transducer 1 (t1):
             a : a
             b : b

             Transducer 2 (t2):
             b : B
             c : C

             Result ( t1.priority_union(t2) ):
             a : a
             b : B
             c : C For more information, read fsmbook.

        """
        return _libhfst.HfstTransducer_priority_union(self, another)

    def lenient_composition(self, another, harmonize=True):
        r"""


        Perform a lenient composition on this transducer and *another*.

        TODO: explain more.

        """
        return _libhfst.HfstTransducer_lenient_composition(self, another, harmonize)

    def cross_product(self, another, harmonize=True):
        r"""


        Make cross product of this transducer with *another*.

        It pairs every string of this with every string of *another*. If strings are not
        the same length, epsilon padding will be added in the end of the shorter string.

        pre: Both transducers must be automata, i.e. map strings onto themselves.

        """
        return _libhfst.HfstTransducer_cross_product(self, another, harmonize)

    def shuffle(self, another, harmonize=True):
        r"""


        Shuffle this transducer with transducer *another*.

        If transducer A accepts string 'foo' and transducer B string 'bar', the
        transducer that results from shuffling A and B accepts all strings
        [(f|b)(o|a)(o|r)].

        pre: Both transducers must be automata, i.e. map strings onto themselves.

        """
        return _libhfst.HfstTransducer_shuffle(self, another, harmonize)

    def remove_epsilons(self):
        r"""


        Remove all *epsilon:epsilon* transitions from the transducer so that the
        resulting transducer is equivalent to the original one.

        """
        return _libhfst.HfstTransducer_remove_epsilons(self)

    def determinize(self):
        r"""


        Determinize the transducer.

        Determinizing a transducer yields an equivalent transducer that has no state
        with two or more transitions whose input:output symbol pairs are the same.

        """
        return _libhfst.HfstTransducer_determinize(self)

    def minimize(self):
        r"""


        Minimize the transducer.

        Minimizing a transducer yields an equivalent transducer with the smallest number
        of states.

        Bug
        OpenFst's minimization algorithm seems to add epsilon transitions to weighted
        transducers?

        """
        return _libhfst.HfstTransducer_minimize(self)

    def prune(self):
        r"""


        Make transducer coaccessible.

        A transducer is coaccessible iff there is a path from every state to a final
        state.

        """
        return _libhfst.HfstTransducer_prune(self)

    def eliminate_flags(self):
        r"""


        Eliminate flag diacritics listed in *symbols* from the transducer.

        Parameters
        ----------
        * `symbols` :
            The flags to be eliminated. TODO: explain more.

        An equivalent transducer with no flags listed in *symbols*.

        """
        return _libhfst.HfstTransducer_eliminate_flags(self)

    def eliminate_flag(self, f):
        r"""


        Eliminate flag diacritic *symbol* from the transducer.

        Parameters
        ----------
        * `symbol` :
            The flag to be eliminated. TODO: explain more.

        An equivalent transducer with no flags *symbol*.

        """
        return _libhfst.HfstTransducer_eliminate_flag(self, f)

    def n_best(self, n):
        r"""


        Extract *n* best paths of the transducer.

        In the case of a weighted transducer (hfst.ImplementationType.TROPICAL_OPENFST_TYPE or
        hfst.ImplementationType.LOG_OPENFST_TYPE), best paths are defined as paths with the lowest
        weight. In the case of an unweighted transducer (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), the function returns random paths.

        This function is not implemented for hfst.ImplementationType.FOMA_TYPE or
        hfst.ImplementationType.SFST_TYPE. If this function is called by an HfstTransducer of type
        hfst.ImplementationType.FOMA_TYPE or hfst.ImplementationType.SFST_TYPE, it is converted to
        hfst.ImplementationType.TROPICAL_OPENFST_TYPE, paths are extracted and it is converted back
        to hfst.ImplementationType.FOMA_TYPE or hfst.ImplementationType.SFST_TYPE. If HFST is not linked to
        OpenFst library, an hfst.exceptions.ImplementationTypeNotAvailableException is
        thrown.

        """
        return _libhfst.HfstTransducer_n_best(self, n)

    def convert(self, impl):
        r"""


        Convert the transducer into an equivalent transducer in format *type*.

        If a weighted transducer is converted into an unweighted one, all weights are
        lost. In the reverse case, all weights are initialized to the semiring's one.

        A transducer of type hfst.ImplementationType.SFST_TYPE, hfst.ImplementationType.TROPICAL_OPENFST_TYPE,
        hfst.ImplementationType.LOG_OPENFST_TYPE or hfst.ImplementationType.FOMA_TYPE can be converted into an
        hfst.ImplementationType.HFST_OL_TYPE or hfst.ImplementationType.HFST_OLW_TYPE transducer, but an
        hfst.ImplementationType.HFST_OL_TYPE or hfst.ImplementationType.HFST_OLW_TYPE transducer cannot be
        converted to any other type.

        note: For conversion between HfstBasicTransducer and HfstTransducer, see
            hfst.HfstTransducer.__init__ and hfst.HfstBasicTransducer.__init__

        """
        return _libhfst.HfstTransducer_convert(self, impl)

    def repeat_star(self):
        r"""


        A concatenation of N transducers where N is any number from zero to infinity.

        """
        return _libhfst.HfstTransducer_repeat_star(self)

    def repeat_plus(self):
        r"""


        A concatenation of N transducers where N is any number from one to infinity.

        """
        return _libhfst.HfstTransducer_repeat_plus(self)

    def repeat_n(self, n):
        r"""


        A concatenation of *n* transducers.

        """
        return _libhfst.HfstTransducer_repeat_n(self, n)

    def repeat_n_to_k(self, n, k):
        r"""


        A concatenation of N transducers where N is any number from *n* to *k*,
        inclusive.

        """
        return _libhfst.HfstTransducer_repeat_n_to_k(self, n, k)

    def repeat_n_minus(self, n):
        r"""


        A concatenation of N transducers where N is any number from zero to *n*,
        inclusive.

        """
        return _libhfst.HfstTransducer_repeat_n_minus(self, n)

    def repeat_n_plus(self, n):
        r"""


        A concatenation of N transducers where N is any number from *n* to infinity,
        inclusive.

        """
        return _libhfst.HfstTransducer_repeat_n_plus(self, n)

    def invert(self):
        r"""


        Swap the input and output symbols of each transition in the transducer.

        """
        return _libhfst.HfstTransducer_invert(self)

    def reverse(self):
        r"""


        Reverse the transducer.

        A reverted transducer accepts the string 'n(0) n(1) ... n(N)' iff the original
        transducer accepts the string 'n(N) n(N-1) ... n(0)'

        """
        return _libhfst.HfstTransducer_reverse(self)

    def input_project(self):
        r"""


        Extract the input language of the transducer.

        All transition symbol pairs *isymbol:osymbol* are changed to *isymbol:isymbol*.

        """
        return _libhfst.HfstTransducer_input_project(self)

    def output_project(self):
        r"""


        Extract the output language of the transducer.

        All transition symbol pairs *isymbol:osymbol* are changed to *osymbol:osymbol*.

        """
        return _libhfst.HfstTransducer_output_project(self)

    def optionalize(self):
        r"""


        Disjunct the transducer with an epsilon transducer.

        """
        return _libhfst.HfstTransducer_optionalize(self)

    def insert_freely(self, *args):
        r"""


        Freely insert a transition or a transducer into the transducer.

        Parameters
        ----------
        * `ins` :
            The transition or transducer to be inserted.

        If *ins* is a transition, i.e. a 2-tuple of strings: A transition is added to
        each state in this transducer. The transition leads from that state to itself
        with input and output symbols defined by *ins*. The weight of the transition is
        zero.

        If *ins* is an hfst.HfstTransducer: A copy of *ins* is attached with epsilon
        transitions to each state of this transducer. After the operation, for each
        state S in this transducer, there is an epsilon transition that leads from state
        S to the initial state of *ins*, and for each final state of *ins*, there is an
        epsilon transition that leads from that final state to state S in this
        transducer. The weights of the final states in *ins* are copied to the epsilon
        transitions leading to state S.

        """
        return _libhfst.HfstTransducer_insert_freely(self, *args)

    def _substitute_symbol(self, old_symbol, new_symbol, input_side=True, output_side=True):
        return _libhfst.HfstTransducer__substitute_symbol(self, old_symbol, new_symbol, input_side, output_side)

    def _substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair):
        return _libhfst.HfstTransducer__substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair)

    def _substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set):
        return _libhfst.HfstTransducer__substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set)

    def _substitute_symbol_pair_with_transducer(self, symbol_pair, transducer, harmonize=True):
        return _libhfst.HfstTransducer__substitute_symbol_pair_with_transducer(self, symbol_pair, transducer, harmonize)

    def _substitute_symbols(self, substitutions):
        return _libhfst.HfstTransducer__substitute_symbols(self, substitutions)

    def _substitute_symbol_pairs(self, substitutions):
        return _libhfst.HfstTransducer__substitute_symbol_pairs(self, substitutions)

    def set_final_weights(self, weight, increment=False):
        r"""


        Set the weights of all final states to *weight*.

        If the HfstTransducer is of unweighted type (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), nothing is done.

        """
        return _libhfst.HfstTransducer_set_final_weights(self, weight, increment)

    def push_weights_to_start(self):
        r"""


        Push weights towards initial state.

        If the HfstTransducer is of unweighted type (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), nothing is done.

        An example:

             >>> import hfst
             >>> tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
             >>> tr.push_weights_to_start()
             >>> print(tr)
             0       1       a       a       2.000000
             1       2       a       b       0.000000
             2       3       b       b       0.000000
             2       0.000000
             3       0.000000

        See also: hfst.HfstTransducer.push_weights_to_end

        """
        return _libhfst.HfstTransducer_push_weights_to_start(self)

    def push_weights_to_end(self):
        r"""


        Push weights towards final state(s).

        If the HfstTransducer is of unweighted type (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), nothing is done.

        An example:

             >>> import hfst
             >>> tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
             >>> tr.push_weights_to_end()
             >>> print(tr)
             0       1       a       a       0.000000
             1       2       a       b       0.000000
             2       3       b       b       0.000000
             2       2.000000
             3       2.000000

        See also: hfst.HfstTransducer.push_weights_to_start

        """
        return _libhfst.HfstTransducer_push_weights_to_end(self)

    def minus(self, t, harmonize=True):
        r"""


        Alias for subtract.

        See also: hfst.HfstTransducer.subtract

        """
        return _libhfst.HfstTransducer_minus(self, t, harmonize)

    def conjunct(self, t, harmonize=True):
        r"""


        Alias for intersect.

        See also: hfst.HfstTransducer.intersect

        """
        return _libhfst.HfstTransducer_conjunct(self, t, harmonize)

    def lookup_optimize(self):
        r"""


        Optimize the transducer for lookup.

        This effectively converts the transducer into hfst.ImplementationType.HFST_OL_TYPE.

        """
        return _libhfst.HfstTransducer_lookup_optimize(self)

    def remove_optimization(self):
        r"""


        Remove lookup optimization.

        This effectively converts transducer (back) into default fst type.

        """
        return _libhfst.HfstTransducer_remove_optimization(self)

    def __init__(self, *args):
        _libhfst.HfstTransducer_swiginit(self, _libhfst.new_HfstTransducer(*args))
    __swig_destroy__ = _libhfst.delete_HfstTransducer

    def __str__(self):
        r"""


        An AT&T representation of the transducer.

        Defined for print command. An example:

             >>> print(hfst.regex('[foo:bar::2]+'))
             0       1       foo     bar     2.000000
             1       1       foo     bar     2.000000
             1       0.000000 Todo
        Works only for small transducers.

        """
        return _libhfst.HfstTransducer___str__(self)

    def write(self, os):
        r"""


        Write the transducer in binary format to *ostr*.

        Parameters
        ----------
        * `ostr` :
            A hfst.HfstOutputStream where the transducer is written.

        """
        return _libhfst.HfstTransducer_write(self, os)

    def _extract_shortest_paths(self):
        return _libhfst.HfstTransducer__extract_shortest_paths(self)

    def _extract_longest_paths(self, obey_flags):
        return _libhfst.HfstTransducer__extract_longest_paths(self, obey_flags)

    def _extract_paths(self, max_num=-1, cycles=-1):
        return _libhfst.HfstTransducer__extract_paths(self, max_num, cycles)

    def _extract_paths_fd(self, max_num=-1, cycles=-1, filter_fd=True):
        return _libhfst.HfstTransducer__extract_paths_fd(self, max_num, cycles, filter_fd)

    def _extract_random_paths(self, max_num):
        return _libhfst.HfstTransducer__extract_random_paths(self, max_num)

    def _extract_random_paths_fd(self, max_num, filter_fd):
        return _libhfst.HfstTransducer__extract_random_paths_fd(self, max_num, filter_fd)

    def _lookup_vector(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst.HfstTransducer__lookup_vector(self, s, limit, time_cutoff)

    def _lookup_fd_vector(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst.HfstTransducer__lookup_fd_vector(self, s, limit, time_cutoff)

    def _lookup_fd_string(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst.HfstTransducer__lookup_fd_string(self, s, limit, time_cutoff)

    def _lookup_string(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst.HfstTransducer__lookup_string(self, s, limit, time_cutoff)


    def copy(self):
        """
        Return a deep copy of the transducer.
        """
        return HfstTransducer(self)

    def write_to_file(self, filename_):
        """
        Write the transducer in binary format to file *filename_*.
        """
        ostr = HfstOutputStream(filename=filename_, type=self.get_type(), hfst_format=True)
        ostr.write(self)
        ostr.close()

    def read_from_file(filename_):
        """
        Read a binary transducer from file *filename_*.
        """
        istr = HfstInputStream(filename_)
        tr = istr.read()
        istr.close()
        return tr

    def write_prolog(self, f, write_weights=True):
        """
        Write the transducer in prolog format with name *name* to file *f*,
        *write_weights* defined whether weights are written.

        Parameters
        ----------
        * `f` :
            A python file where the transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstBasicTransducer(self)
        fsm.name = self.get_name()
        prologstr = fsm.get_prolog_string(write_weights)
        f.write(prologstr)

    def write_xfst(self, f, write_weights=True):
        """
        Write the transducer in xfst format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstBasicTransducer(self)
        fsm.name = self.get_name()
        xfststr = fsm.get_xfst_string(write_weights)
        f.write(xfst)

    def write_att(self, f, write_weights=True):
        """
        Write the transducer in AT&T format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstBasicTransducer(self)
        fsm.name = self.get_name()
        attstr = fsm.get_att_string(write_weights)
        f.write(attstr)

    def lookup(self, input, **kwargs):
        """
        Lookup string *input*.

        Parameters
        ----------
        * `input` :
            The input. A string or a pre-tokenized tuple of symbols (i.e. a tuple of strings).
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True,
            max_number=-1, time_cutoff=0.0, output='tuple'
        * `obey_flags` :
            Whether flag diacritics are obeyed. Always True for HFST_OL(W)_TYPE transducers.
        * `max_number` :
            Maximum number of results returned, defaults to -1, i.e. infinity.
        * `time_cutoff` :
            How long the function can search for results before returning, expressed in
            seconds. Defaults to 0.0, i.e. infinitely. Always 0.0 for transducers that are
            not of HFST_OL(W)_TYPE.
        * `output` :
            Possible values are 'tuple', 'text' and 'raw', 'tuple' being the default.

        Note: This function has an efficient implementation only for optimized lookup format
        (hfst.ImplementationType.HFST_OL_TYPE or hfst.ImplementationType.HFST_OLW_TYPE). Other formats perform the
        lookup via composition. Consider converting the transducer to optimized lookup format
        or to a HfstBasicTransducer. Conversion to HFST_OL(W)_TYPE might take a while but the
        lookup is fast. Conversion to HfstBasicTransducer is quick but lookup is slower.
        """
        obey_flags=True
        max_number=-1
        time_cutoff=0.0
        output='tuple' # 'tuple' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags':
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output='text'
               elif v == 'raw':
                  output='raw'
               elif v == 'tuple':
                  output='tuple'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'tuple' (default), 'text', 'raw'.")
            elif k == 'max_number' :
               max_number=v
            elif k == 'time_cutoff' :
               time_cutoff=v
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval=0

        if isinstance(input, tuple):
           if obey_flags:
              retval=self._lookup_fd_vector(input, max_number, time_cutoff)
           else:
              retval=self._lookup_vector(input, max_number, time_cutoff)
        elif isinstance(input, str):
           if obey_flags:
              retval=self._lookup_fd_string(input, max_number, time_cutoff)
           else:
              retval=self._lookup_string(input, max_number, time_cutoff)
        else:
           try:
              if obey_flags:
                  retval=self._lookup_fd_string(str(input), max_number, time_cutoff)
              else:
                  retval=self._lookup_string(str(input), max_number, time_cutoff)
           except:
              raise RuntimeError('Input argument must be string or tuple.')

        if output == 'text':
           return one_level_paths_to_string(retval)
        elif output == 'tuple':
           return _one_level_paths_to_tuple(retval)
        else:
           return retval

    def extract_longest_paths(self, **kwargs):
        """
        Extract longest paths of the transducer.

        Parameters
        ----------
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True,
            output='dict'
        * `obey_flags` :
            Whether flag diacritics are obeyed. The default is True.
        * `output` :
            Possible values are 'dict', 'text' and 'raw', 'dict' being the default.

        """
        obey_flags=True
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags':
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._extract_longest_paths(obey_flags)

        if output == 'text':
           return two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def extract_shortest_paths(self, **kwargs):
        """
        Extract shortest paths of the transducer.

        Parameters
        ----------
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True.
        * `output` :
            Possible values are 'dict', 'text' and 'raw', 'dict' being the default.

        """
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._extract_shortest_paths()

        if output == 'text':
           return two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def extract_paths(self, **kwargs):
        """

        Extract paths that are recognized by the transducer.

        Parameters
        ----------
        * `kwargs` :
            Arguments recognized are filter_flags, max_cycles, max_number, obey_flags,
            output, random.
        * `filter_flags` :
            Whether flags diacritics are filtered out from the result (default True).
        * `max_cycles` :
            Indicates how many times a cycle will be followed, with negative numbers
            indicating unlimited (default -1 i.e. unlimited).
        * `max_number` :
            The total number of resulting strings is capped at this value, with 0 or
            negative indicating unlimited (default -1 i.e. unlimited).
        * `obey_flags` :
            Whether flag diacritics are validated (default True).
        * `output` :
            Output format. Values recognized: 'text' (as a string, separated by
            newlines), 'raw' (a dictionary that maps each input string into a list of
            tuples of an output string and a weight), 'dict' (a dictionary that maps
            each input string into a tuple of tuples of an output string and a weight,
            the default).
        * `random` :
            Whether result strings are fetched randomly (default False).

        Returns
        -------
        The extracted strings. *output* controls how they are represented.

        pre: The transducer must be acyclic, if both *max_number* and *max_cycles* have
        unlimited values. Else a hfst.exceptions.TransducerIsCyclicException will be
        thrown.

        An example:

        >>> tr = hfst.regex('a:b+ (a:c+)')
        >>> print(tr)
        0       1       a       b       0.000000
        1       1       a       b       0.000000
        1       2       a       c       0.000000
        1       0.000000
        2       2       a       c       0.000000
        2       0.000000

        >>> print(tr.extract_paths(max_cycles=1, output='text'))
        a:b     0
        aa:bb   0
        aaa:bbc 0
        aaaa:bbcc       0
        aa:bc   0
        aaa:bcc 0

        >>> print(tr.extract_paths(max_number=4, output='text'))
        a:b     0
        aa:bc   0
        aaa:bcc 0
        aaaa:bccc       0

        >>> print(tr.extract_paths(max_cycles=1, max_number=4, output='text'))
        a:b     0
        aa:bb   0
        aa:bc   0
        aaa:bcc 0

        Exceptions
        ----------
        * `TransducerIsCyclicException` :

        See also: hfst.HfstTransducer.n_best
        """
        obey_flags=True
        filter_flags=True
        max_cycles=-1
        max_number=-1
        random=False
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags' :
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'filter_flags' :
               if v == True:
                  pass
               elif v == False:
                  filter_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'max_cycles' :
               max_cycles=v
            elif k == 'max_number' :
               max_number=v
            elif k == 'random' :
               if v == False:
                  pass
               elif v == True:
                  random=True
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output = 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval=0

        if obey_flags :
           if random :
              retval=self._extract_random_paths_fd(max_number, filter_flags)
           else :
              retval=self._extract_paths_fd(max_number, max_cycles)
        else :
           if random :
              retval=self._extract_random_paths(max_number)
           else :
              retval=self._extract_paths(max_number, max_cycles)

        if output == 'text':
           return two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def substitute(self, s, S=None, **kwargs):
        """
        Substitute symbols or transitions in the transducer.

        Parameters
        ----------
        * `s` :
            The symbol or transition to be substituted. Can also be a dictionary of
            substitutions, if S == None.
        * `S` :
            The symbol, transition, a tuple of transitions or a transducer
            (hfst.HfstTransducer) that substitutes *s*.
        * `kwargs` :
            Arguments recognized are 'input' and 'output', their values can be False or
            True, True being the default. These arguments are valid only if *s* and *S*
            are strings, else they are ignored.
        * `input` :
            Whether substitution is performed on input side, defaults to True. Valid
            only if *s* and *S* are strings.
        * `output` :
            Whether substitution is performed on output side, defaults to True. Valid
            only if *s* and \\ S are strings.

        For more information, see hfst.HfstBasicTransducer.substitute. The function
        works similarly, with the exception of argument *S*, which must be
        hfst.HfstTransducer instead of hfst.HfstBasicTransducer.

        See also: hfst.HfstBasicTransducer.substitute
        """
        if S == None:
           if not isinstance(s, dict):
              raise RuntimeError('Sole input argument must be a dictionary.')

           subst_type=""

           for k, v in s.items():
               if _is_string(k):
                  if subst_type == "":
                     subst_type="string"
                  elif subst_type == "string pair":
                     raise RuntimeError('')
                  if not _is_string(v):
                     raise RuntimeError('')
               elif _is_string_pair(k):
                  if subst_type == "":
                     subst_type="string pair"
                  elif subst_type == "string":
                     raise RuntimeError('')
                  if not _is_string_pair(v):
                     raise RuntimeError('')
               else:
                  raise RuntimeError('')

           if subst_type == "string":
              return self._substitute_symbols(s)
           else:
              return self._substitute_symbol_pairs(s)

        if _is_string(s):
           if _is_string(S):
              input=True
              output=True
              for k,v in kwargs.items():
                  if k == 'input':
                     if v == False:
                        input=False
                  elif k == 'output':
                     if v == False:
                        output=False
                  else:
                     raise RuntimeError('Free argument not recognized.')
              return self._substitute_symbol(s, S, input, output)
           else:
              raise RuntimeError('...')
        elif _is_string_pair(s):
           if _is_string_pair(S):
              return self._substitute_symbol_pair(s, S)
           elif _is_string_pair_vector(S):
              return self._substitute_symbol_pair_with_set(s, S)
           elif isinstance(S, HfstTransducer):
              return self._substitute_symbol_pair_with_transducer(s, S, True)
           else:
              raise RuntimeError('...')
        else:
           raise RuntimeError('...')


# Register HfstTransducer in _libhfst:
_libhfst.HfstTransducer_swigregister(HfstTransducer)

def HfstTransducer_is_implementation_type_available(type):
    r"""


    Whether HFST is linked to the transducer library needed by implementation type
    *type*.

    """
    return _libhfst.HfstTransducer_is_implementation_type_available(type)


def create_hfst_output_stream(filename, type, hfst_format):
    return _libhfst.create_hfst_output_stream(filename, type, hfst_format)
class HfstOutputStream(object):
    r"""


    A stream for writing binary transducers.

    An example:

         res = ['foo:bar','0','0 - 0','"?":?','a* b+']
         ostr = hfst.HfstOutputStream(filename='testfile1.hfst')
         for re in res:
             ostr.write(hfst.regex(re))
             ostr.flush()
         ostr.close()

    For more information on HFST transducer structure, see this page.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst.delete_HfstOutputStream

    def flush(self):
        r"""


        Flush the stream.

        """
        return _libhfst.HfstOutputStream_flush(self)

    def close(self):
        r"""


        Close the stream.

        If the stream points to standard output, nothing is done.

        """
        return _libhfst.HfstOutputStream_close(self)

    def redirect(self, arg2):
        return _libhfst.HfstOutputStream_redirect(self, arg2)

    def __init__(self):
        _libhfst.HfstOutputStream_swiginit(self, _libhfst.new_HfstOutputStream())


    def write(self, tr):
        """
        Write one or more transducers to stream.

        Parameters
        ----------
        * `tr` :
            An HfstTransducer or an iterable object of several HfstTransducers.
        """
        if isinstance(tr, HfstTransducer):
            self.redirect(tr)
        else:
            for t in tr:
                if isinstance(t, HfstTransducer):
                    self.redirect(t)
                else:
                    raise RuntimeError('Cannot write objects that are not instances of HfstTransducer')

    def __init__(self, **kwargs):
        """
        Open a stream for writing binary transducers. Note: hfst.HfstTransducer.write_to_file
        is probably the easiest way to write a single binary transducer to a file.

        Parameters
        ----------
        * `kwargs` :
            Arguments recognized are filename, hfst_format, type.
        * `filename` :
            The name of the file where transducers are written. If the file exists, it
            is overwritten. If *filename* is not given, transducers are written to
            standard output.
        * `hfst_format` :
            Whether transducers are written in hfst format (default is True) or as such
            in their backend format.
        * `type` :
            The type of the transducers that will be written to the stream. Default is
            hfst.get_default_fst_type().

        Examples:

    # a stream for writing default type transducers in hfst format to standard output
            ostr = hfst.HfstOutputStream()
            transducer = hfst.regex('foo:bar::0.5')
            ostr.write(transducer)
            ostr.flush()

    # a stream for writing native sfst type transducers to a file
            ostr = hfst.HfstOutputStream(filename='transducer.sfst', hfst_format=False, type=hfst.ImplementationType.SFST_TYPE)
            transducer1 = hfst.regex('foo:bar')
            transducer1.convert(hfst.ImplementationType.SFST_TYPE)  # if not set as the default type
            transducer2 = hfst.regex('bar:baz')
            transducer2.convert(hfst.ImplementationType.SFST_TYPE)  # if not set as the default type
            ostr.write(transducer1)
            ostr.write(transducer2)
            ostr.flush()
            ostr.close()
        """
        filename = ""
        hfst_format = True
        type = _libhfst.get_default_fst_type()
        for k,v in kwargs.items():
            if k == 'filename':
                filename = v
            if k == 'hfst_format':
                hfst_format = v
            if k == 'type':
                type = v
        if filename == "":
            self.this = _libhfst.create_hfst_output_stream("", type, hfst_format)
        else:
            self.this = _libhfst.create_hfst_output_stream(filename, type, hfst_format)


# Register HfstOutputStream in _libhfst:
_libhfst.HfstOutputStream_swigregister(HfstOutputStream)

class HfstInputStream(object):
    r"""


    A stream for reading HFST binary transducers.

    An example:

         istr = hfst.HfstInputStream('testfile1.hfst')
         transducers = []
         while not (istr.is_eof()):
             transducers.append(istr.read())
         istr.close()
         print("Read %i transducers in total." % len(transducers))

    For documentation on the HFST binary transducer format, see here.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstInputStream_swiginit(self, _libhfst.new_HfstInputStream(*args))
    __swig_destroy__ = _libhfst.delete_HfstInputStream

    def close(self):
        r"""


        Close the stream.

        If the stream points to standard input, nothing is done.

        """
        return _libhfst.HfstInputStream_close(self)

    def is_eof(self):
        r"""


        Whether the stream is at end.

        """
        return _libhfst.HfstInputStream_is_eof(self)

    def is_bad(self):
        r"""


        Whether badbit is set.

        """
        return _libhfst.HfstInputStream_is_bad(self)

    def is_good(self):
        r"""


        Whether the state of the stream is good for input operations.

        """
        return _libhfst.HfstInputStream_is_good(self)

    def get_type(self):
        r"""


        The type of the first transducer in the stream.

        By default, all transducers in a stream have the same type, else a
        TransducerTypeMismatchException is thrown when reading the first transducer that
        has a different type than the previous ones.

        """
        return _libhfst.HfstInputStream_get_type(self)

    def read(self):
        r"""


        Return next transducer.

        Exceptions
        ----------
        * `EndOfStreamException` :

        """
        return _libhfst.HfstInputStream_read(self)


    def read_all(self):
        """
        Read all transducers from stream and return them in a list.
        """
        retval = []
        while(not self.is_eof()):
            retval.append(self.read())
        return retval

    def __iter__(self):
        """
        Return *self*. Needed for 'for ... in' statement.
        """
        return self

    def next(self):
        """
        Read next transducer from stream and return it. Needed for 'for ... in' statement.
        """
        if self.is_eof():
            raise StopIteration
        else:
            return self.read();

    def __next__(self):
        """
        Read next transducer from stream and return it. Needed for 'for ... in' statement.
        """
        return self.next()



# Register HfstInputStream in _libhfst:
_libhfst.HfstInputStream_swigregister(HfstInputStream)

class HfstTokenizer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _libhfst.HfstTokenizer_swiginit(self, _libhfst.new_HfstTokenizer())

    def add_skip_symbol(self, symbol):
        return _libhfst.HfstTokenizer_add_skip_symbol(self, symbol)

    def add_multichar_symbol(self, symbol):
        return _libhfst.HfstTokenizer_add_multichar_symbol(self, symbol)

    def tokenize_one_level(self, input_string):
        return _libhfst.HfstTokenizer_tokenize_one_level(self, input_string)

    @staticmethod
    def tokenize_space_separated(str):
        return _libhfst.HfstTokenizer_tokenize_space_separated(str)

    def tokenize(self, *args):
        return _libhfst.HfstTokenizer_tokenize(self, *args)

    @staticmethod
    def check_utf8_correctness(input_string):
        return _libhfst.HfstTokenizer_check_utf8_correctness(input_string)
    __swig_destroy__ = _libhfst.delete_HfstTokenizer

# Register HfstTokenizer in _libhfst:
_libhfst.HfstTokenizer_swigregister(HfstTokenizer)

def HfstTokenizer_tokenize_space_separated(str):
    return _libhfst.HfstTokenizer_tokenize_space_separated(str)

def HfstTokenizer_check_utf8_correctness(input_string):
    return _libhfst.HfstTokenizer_check_utf8_correctness(input_string)

class HfstBasicTransducer(object):
    r"""


    A simple transducer class with tropical weights.

    An example of creating an HfstBasicTransducer [foo:bar baz:baz] with weight 0.4
    from scratch:

          # Create an empty transducer
          # The transducer has initially one start state (number zero)
          # that is not final
          fsm = hfst.HfstBasicTransducer()
          # Add two states to the transducer
          fsm.add_state(1)
          fsm.add_state(2)
          # Create a transition [foo:bar] leading to state 1 with weight 0.1
          tr = hfst.HfstBasicTransition(1, 'foo', 'bar', 0.1)
          # and add it to state zero
          fsm.add_transition(0, tr)
          # Add a transition [baz:baz] with weight 0 from state 1 to state 2
          fsm.add_transition(1, hfst.HfstBasicTransition(2, 'baz', 'baz', 0.0))
          # Set state 2 as final with weight 0.3
          fsm.set_final_weight(2, 0.3)

    An example of iterating through the states and transitions of the above
    transducer when printing them in AT&T format to standard output:

          # Go through all states
          for state, arcs in enumerate(fsm):
            for arc in arcs:
              print('%i ' % (state), end='')
              print(arc)
            if fsm.is_final_state(state):
              print('%i %f' % (state, fsm.get_final_weight(state)) )

    See also: hfst.HfstBasicTransition

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstBasicTransducer_swiginit(self, _libhfst.new_HfstBasicTransducer(*args))
    name = property(_libhfst.HfstBasicTransducer_name_get, _libhfst.HfstBasicTransducer_name_set)

    def add_symbol_to_alphabet(self, symbol):
        return _libhfst.HfstBasicTransducer_add_symbol_to_alphabet(self, symbol)

    def remove_symbol_from_alphabet(self, symbol):
        return _libhfst.HfstBasicTransducer_remove_symbol_from_alphabet(self, symbol)

    def remove_symbols_from_alphabet(self, symbols):
        return _libhfst.HfstBasicTransducer_remove_symbols_from_alphabet(self, symbols)

    def add_symbols_to_alphabet(self, symbols):
        return _libhfst.HfstBasicTransducer_add_symbols_to_alphabet(self, symbols)

    def symbols_used(self):
        return _libhfst.HfstBasicTransducer_symbols_used(self)

    def prune_alphabet(self, force=True):
        return _libhfst.HfstBasicTransducer_prune_alphabet(self, force)

    def get_alphabet(self):
        return _libhfst.HfstBasicTransducer_get_alphabet(self)

    def get_input_symbols(self):
        return _libhfst.HfstBasicTransducer_get_input_symbols(self)

    def get_output_symbols(self):
        return _libhfst.HfstBasicTransducer_get_output_symbols(self)

    def get_transition_pairs(self):
        return _libhfst.HfstBasicTransducer_get_transition_pairs(self)

    def add_state(self, *args):
        return _libhfst.HfstBasicTransducer_add_state(self, *args)

    def get_max_state(self):
        return _libhfst.HfstBasicTransducer_get_max_state(self)

    def states(self):
        return _libhfst.HfstBasicTransducer_states(self)

    def remove_transition(self, s, transition, remove_symbols_from_alphabet=False):
        return _libhfst.HfstBasicTransducer_remove_transition(self, s, transition, remove_symbols_from_alphabet)

    def is_final_state(self, s):
        return _libhfst.HfstBasicTransducer_is_final_state(self, s)

    def get_final_weight(self, s):
        return _libhfst.HfstBasicTransducer_get_final_weight(self, s)

    def set_final_weight(self, s, weight):
        return _libhfst.HfstBasicTransducer_set_final_weight(self, s, weight)

    def remove_final_weight(self, s):
        return _libhfst.HfstBasicTransducer_remove_final_weight(self, s)

    def _transitions(self, s):
        return _libhfst.HfstBasicTransducer__transitions(self, s)

    def is_infinitely_ambiguous(self):
        return _libhfst.HfstBasicTransducer_is_infinitely_ambiguous(self)

    def is_lookup_infinitely_ambiguous(self, s):
        return _libhfst.HfstBasicTransducer_is_lookup_infinitely_ambiguous(self, s)

    def longest_path_size(self):
        return _libhfst.HfstBasicTransducer_longest_path_size(self)

    def _substitute_symbol(self, old_symbol, new_symbol, input_side=True, output_side=True):
        return _libhfst.HfstBasicTransducer__substitute_symbol(self, old_symbol, new_symbol, input_side, output_side)

    def _substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair):
        return _libhfst.HfstBasicTransducer__substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair)

    def _substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set):
        return _libhfst.HfstBasicTransducer__substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set)

    def _substitute_symbol_pair_with_transducer(self, symbol_pair, transducer):
        return _libhfst.HfstBasicTransducer__substitute_symbol_pair_with_transducer(self, symbol_pair, transducer)

    def _substitute_symbols(self, substitutions):
        return _libhfst.HfstBasicTransducer__substitute_symbols(self, substitutions)

    def _substitute_symbol_pairs(self, substitutions):
        return _libhfst.HfstBasicTransducer__substitute_symbol_pairs(self, substitutions)

    def insert_freely(self, *args):
        return _libhfst.HfstBasicTransducer_insert_freely(self, *args)

    def sort_arcs(self):
        return _libhfst.HfstBasicTransducer_sort_arcs(self)

    def disjunct(self, spv, weight):
        return _libhfst.HfstBasicTransducer_disjunct(self, spv, weight)

    def harmonize(self, another):
        return _libhfst.HfstBasicTransducer_harmonize(self, another)

    def _lookup(self, lookup_path, infinite_cutoff, max_weight, obey_flags):
        return _libhfst.HfstBasicTransducer__lookup(self, lookup_path, infinite_cutoff, max_weight, obey_flags)

    def get_prolog_string(self, write_weights):
        return _libhfst.HfstBasicTransducer_get_prolog_string(self, write_weights)

    def get_xfst_string(self, write_weights):
        return _libhfst.HfstBasicTransducer_get_xfst_string(self, write_weights)

    def get_att_string(self, write_weights):
        return _libhfst.HfstBasicTransducer_get_att_string(self, write_weights)

    def __str__(self):
        return _libhfst.HfstBasicTransducer___str__(self)

    def add_transition(self, *args):
        return _libhfst.HfstBasicTransducer_add_transition(self, *args)

    def transitions(self, s):
        """
        ...
        """
        tr = self._transitions(s)
        retval = []
        for i in range(0, len(tr)):
            retval.append(tr[i])
        return retval

    def states_and_transitions(self):
        """
        ...
        """
        retval = []
        for s in self.states():
            retval.append(self.transitions(s))
        return retval

    def __iter__(self):
        """
        Return states and transitions of the transducer.
        """
        return self.states_and_transitions().__iter__()

    def __enumerate__(self):
        """
        Return an enumeration of states and transitions of the transducer.
        """
        return enumerate(self.states_and_transitions())

    def write_prolog(self, f, write_weights=True):
        """
        Write the transducer in prolog format with name *name* to file *f*,
        *write_weights* defined whether weights are written.

        Parameters
        ----------
        * `f` :
            A python file where the transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        prologstr = self.get_prolog_string(write_weights)
        f.write(prologstr)

    def write_xfst(self, f, write_weights=True):
        """
        Write the transducer in xfst format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        xfststr = self.get_xfst_string(write_weights)
        f.write(xfststr)

    def write_att(self, f, write_weights=True):
        """
        Write the transducer in AT&T format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        attstr = self.get_att_string(write_weights)
        f.write(attstr)

    def lookup(self, lookup_path, **kwargs):
        """
        Lookup tokenized input *input* in the transducer.

        Parameters
        ----------
        * `str` :
            A list/tuple of strings to look up.
        * `kwargs` :
            infinite_cutoff=-1, max_weight=None, obey_flags=False
        * `max_epsilon_loops` :
            How many times epsilon input loops are followed. Defaults to -1, i.e. infinitely.
        * `max_weight` :
            What is the maximum weight of a result allowed. Defaults to None, i.e. infinity.
        * `obey_flags` :
            Whether flag diacritic constraints are obeyed. Defaults to False.
        """
        max_weight = None
        max_epsilon_loops = None
        obey_flags = False
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'max_weight' :
               max_weight=v
            elif k == 'max_epsilon_loops' :
               infinite_cutoff=v
            elif k == 'obey_flags' :
               obey_flags=v
            elif k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._lookup(lookup_path, max_epsilon_loops, max_weight, obey_flags)

        if output == 'text':
           return _two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def substitute(self, s, S=None, **kwargs):
        """

        Substitute symbols or transitions in the transducer.

        Parameters
        ----------
        * `s` :
            The symbol or transition to be substituted. Can also be a dictionary of
            substitutions, if S == None.
        * `S` :
            The symbol, transition, a tuple of transitions or a transducer
            (hfst.HfstBasicTransducer) that substitutes *s*.
        * `kwargs` :
            Arguments recognized are 'input' and 'output', their values can be False or
            True, True being the default. These arguments are valid only if *s* and *S*
            are strings, else they are ignored.
        * `input` :
            Whether substitution is performed on input side, defaults to True. Valid
            only if *s* and *S* are strings.
        * `output` :
            Whether substitution is performed on output side, defaults to True. Valid
            only if *s* and *S* are strings.

        Possible combinations of arguments and their types are:

        (1) substitute(str, str, input=bool, output=bool): substitute symbol with symbol
        on input, output or both sides of each transition in the transducer. (2)
        substitute(strpair, strpair): substitute transition with transition (3)
        substitute(strpair, strpairtuple): substitute transition with several
        transitions (4) substitute(strpair, transducer): substitute transition with a
        transducer (5) substitute(dict): perform several symbol-to-symbol substitutions
        (6) substitute(dict): perform several transition-to-transition substitutions

        Examples:

        (1) tr.substitute('a', 'A', input=True, output=False): substitute lowercase a:s
        with uppercase ones (2) tr.substitute(('a','b'),('A','B')): substitute
        transitions that map lowercase a into lowercase b with transitions that map
        uppercase a into uppercase b (3) tr.substitute(('a','b'),
        (('A','B'),('a','B'),('A','b'))): change either or both sides of a transition
        [a:b] to uppercase (4) tr.substitute(('a','b'), hfst.regex('[a:b]+')) change
        [a:b] transition into one or more consecutive [a:b] transitions (5)
        tr.substitute({'a':'A', 'b':'B', 'c':'C'}) change lowercase a, b and c into
        their uppercase variants (6) tr.substitute( {('a','a'):('A','A'),
        ('b','b'):('B','B'), ('c','c'):('C','C')} ): change lowercase a, b and c into
        their uppercase variants

        In case (4), epsilon transitions are used to attach copies of transducer *S*
        between the SOURCE and TARGET state of each transition that is substituted. The
        transition itself is deleted, but its weight is copied to the epsilon transition
        leading from SOURCE to the initial state of *S*. Each final state of *S* is made
        non-final and an epsilon transition leading to TARGET is attached to it. The
        final weight is copied to the epsilon transition.
        """
        if S == None:
           if not isinstance(s, dict):
              raise RuntimeError('First input argument must be a dictionary.')

           subst_type=""

           for k, v in s.items():
               if _is_string(k):
                  if subst_type == "":
                     subst_type="string"
                  elif subst_type == "string pair":
                     raise RuntimeError('')
                  if not _is_string(v):
                     raise RuntimeError('')
               elif _is_string_pair(k):
                  if subst_type == "":
                     subst_type="string pair"
                  elif subst_type == "string":
                     raise RuntimeError('')
                  if not _is_string_pair(v):
                     raise RuntimeError('')
               else:
                  raise RuntimeError('')

           if subst_type == "string":
              return self._substitute_symbols(s)
           else:
              return self._substitute_symbol_pairs(s)

        if _is_string(s):
           if _is_string(S):
              input=True
              output=True
              for k,v in kwargs.items():
                  if k == 'input':
                     if v == False:
                        input=False
                  elif k == 'output':
                     if v == False:
                        output=False
                  else:
                     raise RuntimeError('Free argument not recognized.')
              return self._substitute_symbol(s, S, input, output)
           else:
              raise RuntimeError('...')
        elif _is_string_pair(s):
           if _is_string_pair(S):
              return self._substitute_symbol_pair(s, S)
           elif _is_string_pair_vector(S):
              return self._substitute_symbol_pair_with_set(s, S)
           elif isinstance(S, HfstBasicTransducer):
              return self._substitute_symbol_pair_with_transducer(s, S)
           else:
              raise RuntimeError('...')
        else:
           raise RuntimeError('...')


    __swig_destroy__ = _libhfst.delete_HfstBasicTransducer

# Register HfstBasicTransducer in _libhfst:
_libhfst.HfstBasicTransducer_swigregister(HfstBasicTransducer)

class HfstBasicTransition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.HfstBasicTransition_swiginit(self, _libhfst.new_HfstBasicTransition(*args))
    __swig_destroy__ = _libhfst.delete_HfstBasicTransition

    def get_target_state(self):
        return _libhfst.HfstBasicTransition_get_target_state(self)

    def get_input_symbol(self):
        return _libhfst.HfstBasicTransition_get_input_symbol(self)

    def set_input_symbol(self, symbol):
        return _libhfst.HfstBasicTransition_set_input_symbol(self, symbol)

    def get_output_symbol(self):
        return _libhfst.HfstBasicTransition_get_output_symbol(self)

    def set_output_symbol(self, symbol):
        return _libhfst.HfstBasicTransition_set_output_symbol(self, symbol)

    def get_weight(self):
        return _libhfst.HfstBasicTransition_get_weight(self)

    def set_weight(self, f):
        return _libhfst.HfstBasicTransition_set_weight(self, f)

    def __str__(self):
        return _libhfst.HfstBasicTransition___str__(self)

# Register HfstBasicTransition in _libhfst:
_libhfst.HfstBasicTransition_swigregister(HfstBasicTransition)

class XreCompiler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.XreCompiler_swiginit(self, _libhfst.new_XreCompiler(*args))

    def define_list(self, name, symbol_list):
        return _libhfst.XreCompiler_define_list(self, name, symbol_list)

    def define_function(self, name, arguments, xre):
        return _libhfst.XreCompiler_define_function(self, name, arguments, xre)

    def is_definition(self, name):
        return _libhfst.XreCompiler_is_definition(self, name)

    def is_function_definition(self, name):
        return _libhfst.XreCompiler_is_function_definition(self, name)

    def undefine(self, name):
        return _libhfst.XreCompiler_undefine(self, name)

    def compile(self, xre):
        return _libhfst.XreCompiler_compile(self, xre)

    def set_verbosity(self, verbose):
        return _libhfst.XreCompiler_set_verbosity(self, verbose)

    def getOutputToConsole(self):
        return _libhfst.XreCompiler_getOutputToConsole(self)

    def set_expand_definitions(self, expand):
        return _libhfst.XreCompiler_set_expand_definitions(self, expand)

    def set_harmonization(self, harmonize):
        return _libhfst.XreCompiler_set_harmonization(self, harmonize)

    def contained_only_comments(self):
        return _libhfst.XreCompiler_contained_only_comments(self)

    def define_xre(self, name, xre):
        return _libhfst.XreCompiler_define_xre(self, name, xre)

    def define_transducer(self, name, transducer):
        return _libhfst.XreCompiler_define_transducer(self, name, transducer)

    def setOutputToConsole(self, value):
        return _libhfst.XreCompiler_setOutputToConsole(self, value)

    def compile_first(self, xre):
        return _libhfst.XreCompiler_compile_first(self, xre)
    __swig_destroy__ = _libhfst.delete_XreCompiler

# Register XreCompiler in _libhfst:
_libhfst.XreCompiler_swigregister(XreCompiler)

class LexcCompiler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.LexcCompiler_swiginit(self, _libhfst.new_LexcCompiler(*args))

    def setVerbosity(self, verbose):
        return _libhfst.LexcCompiler_setVerbosity(self, verbose)

    def setOutputToConsole(self, arg2):
        return _libhfst.LexcCompiler_setOutputToConsole(self, arg2)
    __swig_destroy__ = _libhfst.delete_LexcCompiler

# Register LexcCompiler in _libhfst:
_libhfst.LexcCompiler_swigregister(LexcCompiler)

class XfstCompiler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libhfst.XfstCompiler_swiginit(self, _libhfst.new_XfstCompiler(*args))

    def setOutputToConsole(self, value):
        return _libhfst.XfstCompiler_setOutputToConsole(self, value)

    def setReadInteractiveTextFromStdin(self, Value):
        return _libhfst.XfstCompiler_setReadInteractiveTextFromStdin(self, Value)

    def setReadline(self, value):
        return _libhfst.XfstCompiler_setReadline(self, value)

    def setVerbosity(self, verbosity):
        return _libhfst.XfstCompiler_setVerbosity(self, verbosity)

    def set(self, name, text):
        return _libhfst.XfstCompiler_set(self, name, text)

    def get_prompt(self):
        return _libhfst.XfstCompiler_get_prompt(self)

    def apply_up(self, indata):
        return _libhfst.XfstCompiler_apply_up(self, indata)

    def apply_down(self, indata):
        return _libhfst.XfstCompiler_apply_down(self, indata)

    def parse_line(self, line):
        return _libhfst.XfstCompiler_parse_line(self, line)

    def quit_requested(self):
        return _libhfst.XfstCompiler_quit_requested(self)
    __swig_destroy__ = _libhfst.delete_XfstCompiler

# Register XfstCompiler in _libhfst:
_libhfst.XfstCompiler_swigregister(XfstCompiler)


def get_hfst_regex_error_message():
    return _libhfst.get_hfst_regex_error_message()

def hfst_regex(comp, regex_string, error_stream):
    return _libhfst.hfst_regex(comp, regex_string, error_stream)

def get_hfst_xfst_string_one():
    return _libhfst.get_hfst_xfst_string_one()

def get_hfst_xfst_string_two():
    return _libhfst.get_hfst_xfst_string_two()

def hfst_compile_xfst_to_string_one(comp, input):
    return _libhfst.hfst_compile_xfst_to_string_one(comp, input)

def hfst_compile_xfst(comp, input, output_stream, error_stream):
    return _libhfst.hfst_compile_xfst(comp, input, output_stream, error_stream)

def get_hfst_lexc_output():
    return _libhfst.get_hfst_lexc_output()

def hfst_compile_lexc(comp, filename, error_stream):
    return _libhfst.hfst_compile_lexc(comp, filename, error_stream)

def get_hfst_sfst_output():
    return _libhfst.get_hfst_sfst_output()

def hfst_compile_sfst(filename, error_stream, verbose, output_to_console):
    return _libhfst.hfst_compile_sfst(filename, error_stream, verbose, output_to_console)

def one_level_paths_to_string(arg1):
    return _libhfst.one_level_paths_to_string(arg1)

def two_level_paths_to_string(arg1):
    return _libhfst.two_level_paths_to_string(arg1)

def parse_prolog_network_line(line, graph):
    return _libhfst.parse_prolog_network_line(line, graph)

def parse_prolog_arc_line(line, graph):
    return _libhfst.parse_prolog_arc_line(line, graph)

def parse_prolog_symbol_line(line, graph):
    return _libhfst.parse_prolog_symbol_line(line, graph)

def parse_prolog_final_line(line, graph):
    return _libhfst.parse_prolog_final_line(line, graph)

def set_default_fst_type(t):
    r"""


    Set the default implementation type.

    Parameters
    ----------
    * `impl` :
        An hfst.ImplementationType.

    Set the implementation type (SFST_TYPE, TROPICAL_OPENFST_TYPE, FOMA_TYPE) that
    is used by default by all operations that create transducers. The default value
    is TROPICAL_OPENFST_TYPE

    """
    return _libhfst.set_default_fst_type(t)

def get_default_fst_type():
    r"""


    Get default transducer implementation type.

    If the default type is not set, it defaults to hfst.ImplementationType.TROPICAL_OPENFST_TYPE

    """
    return _libhfst.get_default_fst_type()

def fst_type_to_string(t):
    r"""


    Get a string representation of transducer implementation type *type*.

    Parameters
    ----------
    * `type` :
        An hfst.ImplementationType.

    """
    return _libhfst.fst_type_to_string(t)

def two_level_if(context, mappings, alphabet):
    return _libhfst.two_level_if(context, mappings, alphabet)

def two_level_only_if(context, mappings, alphabet):
    return _libhfst.two_level_only_if(context, mappings, alphabet)

def two_level_if_and_only_if(context, mappings, alphabet):
    return _libhfst.two_level_if_and_only_if(context, mappings, alphabet)

def replace_down_karttunen(context, mapping, optional, alphabet):
    return _libhfst.replace_down_karttunen(context, mapping, optional, alphabet)

def replace_right(context, mapping, optional, alphabet):
    return _libhfst.replace_right(context, mapping, optional, alphabet)

def replace_left(context, mapping, optional, alphabet):
    return _libhfst.replace_left(context, mapping, optional, alphabet)

def replace_up(mapping, optional, alphabet):
    return _libhfst.replace_up(mapping, optional, alphabet)

def replace_down(*args):
    return _libhfst.replace_down(*args)

def left_replace_up(*args):
    return _libhfst.left_replace_up(*args)

def left_replace_down(context, mapping, optional, alphabet):
    return _libhfst.left_replace_down(context, mapping, optional, alphabet)

def left_replace_down_karttunen(context, mapping, optional, alphabet):
    return _libhfst.left_replace_down_karttunen(context, mapping, optional, alphabet)

def left_replace_left(context, mapping, optional, alphabet):
    return _libhfst.left_replace_left(context, mapping, optional, alphabet)

def left_replace_right(context, mapping, optional, alphabet):
    return _libhfst.left_replace_right(context, mapping, optional, alphabet)

def restriction(contexts, mapping, alphabet):
    return _libhfst.restriction(contexts, mapping, alphabet)

def coercion(contexts, mapping, alphabet):
    return _libhfst.coercion(contexts, mapping, alphabet)

def restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst.restriction_and_coercion(contexts, mapping, alphabet)

def surface_restriction(contexts, mapping, alphabet):
    return _libhfst.surface_restriction(contexts, mapping, alphabet)

def surface_coercion(contexts, mapping, alphabet):
    return _libhfst.surface_coercion(contexts, mapping, alphabet)

def surface_restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst.surface_restriction_and_coercion(contexts, mapping, alphabet)

def deep_restriction(contexts, mapping, alphabet):
    return _libhfst.deep_restriction(contexts, mapping, alphabet)

def deep_coercion(contexts, mapping, alphabet):
    return _libhfst.deep_coercion(contexts, mapping, alphabet)

def deep_restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst.deep_restriction_and_coercion(contexts, mapping, alphabet)
class TwolcCompiler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def compile(inputfile, outputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type):
        return _libhfst.TwolcCompiler_compile(inputfile, outputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type)

    def __init__(self):
        _libhfst.TwolcCompiler_swiginit(self, _libhfst.new_TwolcCompiler())
    __swig_destroy__ = _libhfst.delete_TwolcCompiler

# Register TwolcCompiler in _libhfst:
_libhfst.TwolcCompiler_swigregister(TwolcCompiler)

def TwolcCompiler_compile(inputfile, outputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type):
    return _libhfst.TwolcCompiler_compile(inputfile, outputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type)


def pmatch_get_tokenized_output(cont, input_text, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar):
    return _libhfst.pmatch_get_tokenized_output(cont, input_text, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar)

def pmatch_locate(*args):
    return _libhfst.pmatch_locate(*args)
class PmatchContainer(object):
    r"""


    A class for performing pattern matching.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst.delete_PmatchContainer

    def match(self, input, time_cutoff=0.0):
        r"""


        Match input *input*.

        """
        return _libhfst.PmatchContainer_match(self, input, time_cutoff)

    def get_profiling_info(self):
        r"""


        todo

        """
        return _libhfst.PmatchContainer_get_profiling_info(self)

    def set_verbose(self, b):
        r"""


        todo

        """
        return _libhfst.PmatchContainer_set_verbose(self, b)

    def set_profile(self, b):
        r"""


        todo

        """
        return _libhfst.PmatchContainer_set_profile(self, b)

    def __init__(self, *args):
        _libhfst.PmatchContainer_swiginit(self, _libhfst.new_PmatchContainer(*args))

    def locate(self, *args):
        r"""


        The locations of pmatched strings for string *input* where the results are limited
        as defined by *time_cutoff* and *weight_cutoff*.

        Parameters
        ----------
        * `input` :
            The input string.
        * `time_cutoff` :
            Time cutoff, defaults to zero, i.e. no cutoff.
        * `weight_cutoff` :
            Weight cutoff, defaults to infinity, i.e. no cutoff.

        Returns
        -------
        A tuple of tuples of Location.

        """
        return _libhfst.PmatchContainer_locate(self, *args)

    def get_tokenized_output(self, input, **kwargs):
        """
        Tokenize *input* and get a string representation of the tokenization
        (essentially the same that command line tool hfst-tokenize would give).

        Parameters
        ----------
        * `input` :
            The input string to be tokenized.
        * `kwargs` :
            Possible parameters are:
            output_format, max_weight_classes, dedupe, print_weights, print_all,
            time_cutoff, verbose, beam, tokenize_multichar.
        * `output_format` :
            The format of output; possible values are 'tokenize', 'xerox', 'cg', 'finnpos',
            'giellacg', 'conllu' and 'visl'; 'tokenize' being the default.
        * `max_weight_classes` :
            Maximum number of best weight classes to output
            (where analyses with equal weight constitute a class), defaults to None i.e. no limit.
        * `dedupe` :
            Whether duplicate analyses are removed, defaults to False.
        * `print_weights` :
            Whether weights are printd, defaults to False.
        * `print_all` :
            Whether nonmatching text is printed, defaults to False.
        * `time_cutoff` :
            Maximum number of seconds used per input after limiting the search.
        * `verbose` :
            Whether input is processed verbosely, defaults to True.
        * `beam` :
            Beam within analyses must be to get printed.
        * `tokenize_multichar` :
            Tokenize input into multicharacter symbols present in the transducer, defaults to false.
        """
        output_format='tokenize'
        max_weight_classes=None
        dedupe=False
        print_weights=False
        print_all=False
        time_cutoff=0.0
        verbose=True
        beam=-1.0
        tokenize_multichar=False
        for k,v in kwargs.items():
           if k == 'output_format':
              if v == 'tokenize' or v == 'space_separated' or v == 'xerox' or v == 'cg' or v == 'finnpos' or v == 'giellacg' or v == 'conllu':
                 output_format=v
              else:
                 print('Warning: ignoring unknown value %s for argument %s.' % (v,k))
           elif k == 'max_weight_classes':
              max_weight_classes=int(v)
           elif k == 'dedupe':
              dedupe=v
           elif k == 'print_weights':
              print_weights=v
           elif k == 'print_all':
              print_all=v
           elif k == 'time_cutoff':
              time_cutoff=float(v)
           elif k == 'verbose':
              verbose=v
           elif k == 'beam':
              beam=float(v)
           elif k == 'tokenize_multichar':
              tokenize_multichar=v
           else:
              print('Warning: ignoring unknown argument %s.' % (k))
        return pmatch_get_tokenized_output(self, input, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar)

    def tokenize(self, input):
        """
        Tokenize *input* and return a list of tokens i.e. strings.

        Parameters
        ----------
        * `input` :
            The string to be tokenized.
        """
        retval = []
        locations = self.locate(input)
        for loc in locations:
           if loc[0].output != "@_NONMATCHING_@":
              retval.append(loc[0].input)
        return retval



# Register PmatchContainer in _libhfst:
_libhfst.PmatchContainer_swigregister(PmatchContainer)



class ImplementationType:
    """
    Back-end implementation.

    Attributes:

        SFST_TYPE:               SFST type, unweighted
        TROPICAL_OPENFST_TYPE:   OpenFst type with tropical weights
        LOG_OPENFST_TYPE:        OpenFst type with logarithmic weights (limited support)
        FOMA_TYPE:               FOMA type, unweighted
        XFSM_TYPE:               XFST type, unweighted (limited support)
        HFST_OL_TYPE:            HFST optimized-lookup type, unweighted
        HFST_OLW_TYPE:           HFST optimized-lookup type, weighted
        HFST2_TYPE:              HFST version 2 legacy type
        UNSPECIFIED_TYPE:        type not specified
        ERROR_TYPE:              (something went wrong)

    """
    SFST_TYPE = _libhfst.SFST_TYPE
    TROPICAL_OPENFST_TYPE = _libhfst.TROPICAL_OPENFST_TYPE    
    LOG_OPENFST_TYPE = _libhfst.LOG_OPENFST_TYPE
    FOMA_TYPE = _libhfst.FOMA_TYPE
    XFSM_TYPE = _libhfst.XFSM_TYPE
    HFST_OL_TYPE = _libhfst.HFST_OL_TYPE
    HFST_OLW_TYPE = _libhfst.HFST_OLW_TYPE
    HFST2_TYPE = _libhfst.HFST2_TYPE
    UNSPECIFIED_TYPE = _libhfst.UNSPECIFIED_TYPE
    ERROR_TYPE = _libhfst.ERROR_TYPE

class ReplaceType:
    """
    Replace type in Xerox-type rules.

    Attributes:

        REPL_UP:      Match contexts on input level
        REPL_DOWN:    Match contexts on output level
        REPL_RIGHT:   Match left contexts on input level and right contexts on output level
        REPL_LEFT:    Match left contexts on output level and right contexts on input level

    """
    REPL_UP = _libhfst.REPL_UP
    REPL_DOWN = _libhfst.REPL_DOWN
    REPL_RIGHT = _libhfst.REPL_RIGHT
    REPL_LEFT = _libhfst.REPL_LEFT




